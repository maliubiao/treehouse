### 技术变更文档

#### 1. 变更概述
*   **目标**: 在框架模式(Skeleton Mode)下增加局部细节切换功能，允许用户在不退出全局框架视图的情况下，按需展开/折叠单个函数调用的详细日志。
*   **主要改动**: 
    1. 在函数调用行添加"Toggle Details"按钮(👁️)
    2. 实现CSS规则控制局部详细日志的显示
    3. 新增JavaScript事件处理切换逻辑
*   **影响范围**: 
    - `debugger/tracer_html.py` (UI结构)
    - `debugger/tracer_styles.css` (样式规则)
    - `debugger/tracer_scripts.js` (交互逻辑)

#### 2. 实现思路
*   **问题分析**: 全局框架模式在大型日志中性能良好但缺乏局部细节查看能力，强制退出框架模式会导致页面卡顿
*   **架构设计**: 
    - 新增UI控件仅框架模式可见
    - CSS类切换控制局部显示状态
    - 事件委托优化性能
*   **关键技术决策**:
    - CSS优先方案: 利用浏览器渲染引擎而非JS DOM操作，优化大型日志性能
    - 状态反馈: 通过图标变化(👁️ ↔ 📦)和标题更新提供明确状态指示
    - 关注点分离: HTML/CSS/JS各司其职，最小化代码侵入
*   **关键逻辑**:
    1. 按钮点击时切换父容器`.call-group`的`show-details`类
    2. CSS覆盖规则强制显示被隐藏的详细日志元素
    3. 按钮状态与容器类保持同步
*   **diff验证**: 实际变更与LLM设计方案完全一致

#### 3. 详细变更
##### 文件: `debugger/tracer_html.py`
在函数调用行操作区新增"Toggle Details"按钮
```python
# 修改前
copy_subtree_html = ' <span class="copy-subtree-btn" title="Copy subtree as text">📋</span>'
focus_subtree_html = ' <span class="focus-subtree-btn" title="Focus on this subtree (crop)">🔍</span>'
actions_html = copy_subtree_html + focus_subtree_html

# 修改后
copy_subtree_html = ' <span class="copy-subtree-btn" title="Copy subtree as text">📋</span>'
focus_subtree_html = ' <span class="focus-subtree-btn" title="Focus on this subtree (crop)">🔍</span>'
toggle_details_html = ' <span class="toggle-details-btn" title="Show details for this subtree">👁️</span>'  # 新增按钮
actions_html = copy_subtree_html + focus_subtree_html + toggle_details_html  # 集成新按钮
```

##### 文件: `debugger/tracer_styles.css`
新增局部细节显示的CSS规则
```css
/* 新增按钮基础样式 */
.toggle-details-btn {
    display: none;
    margin-left: 8px;
    cursor: pointer;
    font-size: 0.9em;
    user-select: none;
}

/* 框架模式下显示按钮 */
body.skeleton-mode .foldable:hover .toggle-details-btn {
    display: inline-block;
}

/* 覆盖框架模式的隐藏规则 (关键变更) */
body.skeleton-mode .call-group.show-details .line,
body.skeleton-mode .call-group.show-details .trace,
body.skeleton-mode .call-group.show-details .var {
    display: block;  /* 强制显示详细日志 */
}
```

##### 文件: `debugger/tracer_scripts.js`
新增局部细节切换功能实现
```javascript
// 在TraceViewer对象中新增方法
initToggleDetails() {
    this.elements.content.addEventListener('click', e => {
        if (!e.target.classList.contains('toggle-details-btn')) return;
        
        e.preventDefault();
        e.stopPropagation();
        
        const toggleBtn = e.target;
        const foldable = toggleBtn.closest('.foldable.call');
        const callGroup = foldable?.nextElementSibling;
        
        if (!callGroup?.classList.contains('call-group')) return;

        // 切换细节显示状态
        callGroup.classList.toggle('show-details');
        
        // 更新按钮状态
        if (callGroup.classList.contains('show-details')) {
            toggleBtn.textContent = '📦';
            toggleBtn.title = 'Hide details for this subtree';
        } else {
            toggleBtn.textContent = '👁️';
            toggleBtn.title = 'Show details for this subtree';
        }
    });
},

// 在init()中调用新方法
init() {
    // ...其他初始化...
    this.initToggleDetails();  // 新增调用
}
```

#### 4. 测试覆盖计划
*   **测试点1：基础功能验证**
    *   **操作**: 启用框架模式，在函数调用行悬停并点击"👁️"按钮
    *   **输入**: 包含多层级函数调用的大型日志文件
    *   **期望输出**: 
        1. 仅当前函数子树下的.line/.trace/.var日志显示
        2. 按钮图标变为"📦"，提示文本更新
        3. 页面其他区域保持框架模式

*   **测试点2：状态切换与保持**
    *   **操作**: 在已展开细节的函数调用上再次点击按钮
    *   **输入**: 已展开局部细节的函数调用
    *   **期望输出**: 
        1. 详细日志正确折叠隐藏
        2. 按钮图标恢复为"👁️"，提示文本还原
        3. 展开/折叠动画流畅无闪烁

*   **测试点3：边缘情况测试**
    *   **操作1**: 在超深层级(>10层)函数调用中切换细节
    *   **输入**: 深度嵌套的函数调用结构
    *   **期望输出**: 局部展开/折叠性能正常(响应时间<200ms)
    
    *   **操作2**: 连续快速点击多个函数的切换按钮
    *   **输入**: 相邻的多个函数调用行
    *   **期望输出**: 各函数子树独立保持展开/折叠状态，无状态冲突

*   **测试点4：回归测试提醒**
    *   **操作**: 
        1. 框架模式全局切换功能
        2. 复制子树功能
        3. 聚焦子树功能
    *   **期望输出**: 
        1. 确认新增功能不影响现有功能
        2. 按钮布局无重叠错位
        3. 控制台无新增错误日志

#### 5. End-to-End Testing (Playwright)
*   **目的**: 为确保"局部细节切换"功能在真实浏览器环境中的正确性，我们引入了Playwright进行端到端自动化测试，以模拟并验证用户的实际操作流程。
*   **测试文件**: `tests/test_debugger_report_interaction.py`
*   **测试设置**:
    -   **框架**: 基于 `pytest` 和 `pytest-playwright`。
    -   **测试数据**: 测试启动时，通过 `pytest` 的 fixture 动态生成一个包含嵌套函数调用的HTML跟踪报告(`interaction_test_report.html`)。这确保了测试的独立性和一致性。
*   **核心测试流程**:
    1.  **启动与导航**: Playwright启动浏览器并打开动态生成的HTML报告。
    2.  **进入框架模式**: 模拟用户点击"框架模式"按钮，并断言 `<body>` 元素已正确应用 `skeleton-mode` CSS类。
    3.  **悬停与可见性**: 定位到一个函数调用，断言"切换细节"按钮(👁️)初始为不可见。随后模拟鼠标悬停，断言该按钮变为可见。
    4.  **展开细节**: 点击"👁️"按钮，并断言：
        -   按钮图标变为"📦"。
        -   目标函数调用块获得了 `show-details` CSS类。
        -   该函数块内的详细日志行（`.line`）从隐藏状态变为可见。
        -   报告中其他部分的日志行仍然保持隐藏，验证了功能的局部性。
    5.  **折叠细节**: 再次点击"📦"按钮，并断言：
        -   按钮图标恢复为"👁️"。
        -   `show-details` CSS类被移除。
        -   详细日志行重新变为不可见。
*   **验证范围**: 该测试不仅验证了功能的逻辑正确性（如CSS类的切换），还通过对元素可见性的断言，覆盖了相关的CSS样式规则，确保了功能在视觉层面也符合预期。