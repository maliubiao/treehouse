#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
A post-processing tool to compress tracer's text output for LLM context.

This script reads a raw text log file generated by the context-tracer and
compresses it by:
1. Replacing leading spaces with tabs for efficiency (1 tab = 2 spaces).
2. Removing redundant file paths for consecutive lines within the same function scope
   to reduce context size. File paths are shown only at the start of a new
   function scope (e.g., after a CALL or EXCEPTION event).

Usage:
    python text_to_llm_context.py /path/to/trace.log > compressed_trace.log
"""

import argparse
import re
import sys
from pathlib import Path
from typing import Dict, Tuple

# Regex to capture elements from lines containing file paths.
# The path is captured to enable replacement with padding for alignment.
RE_CALL = re.compile(r"^(?P<icon>↘ (?:CALL|MODULE)) (?P<path>.+?):(?P<lineno>\d+)(?P<rest>.*)$")
RE_LINE = re.compile(r"^(?P<icon>▷) (?P<path>.+?):(?P<lineno>\d+)(?P<rest>.*)$")
RE_EXCEPTION = re.compile(r"^(?P<icon>⚠ EXCEPTION) .*? AT (?P<path>.+?):(?P<lineno>\d+)(?P<rest>.*)$")


def process_log_file(file_path: Path) -> None:
    """
    Processes a log file and prints the compressed version to stdout.

    Args:
        file_path: The path to the input log file.
    """
    if not file_path.is_file():
        print(f"Error: File not found at {file_path}", file=sys.stderr)
        sys.exit(1)

    # Stores context information (path, path_length) for a given indentation depth.
    # Key: depth (int), Value: (path (str), path_length (int))
    path_info_at_depth: Dict[int, Tuple[str, int]] = {}

    with open(file_path, "r", encoding="utf-8") as f:
        for line in f:
            # Strip trailing newline for consistent processing
            line = line.rstrip("\n")

            num_spaces: int = len(line) - len(line.lstrip(" "))
            content: str = line.lstrip(" ")

            # Skip empty lines
            if not content:
                print()
                continue

            # Assume 2 spaces per indentation level, which is the tracer's standard.
            # If not, it might be a multi-line string from a variable, so print as is.
            if num_spaces % 2 != 0:
                print(line)
                continue

            depth: int = num_spaces // 2
            tabs: str = "\t" * depth

            # When de-indenting, clean up path contexts that are no longer in scope.
            for d in list(path_info_at_depth.keys()):
                if d >= depth:
                    del path_info_at_depth[d]

            match_call = RE_CALL.match(content)
            match_exception = RE_EXCEPTION.match(content)
            match_line = RE_LINE.match(content)

            # CALL and EXCEPTION events establish a new path context for their depth.
            if match_call or match_exception:
                match = match_call or match_exception
                assert match is not None  # for type checker
                path = match.group("path")
                # Store the path and its length for alignment of subsequent lines.
                path_info_at_depth[depth] = (path, len(path))
                print(f"{tabs}{content}")

            # LINE events may have their path compressed.
            elif match_line:
                path = match_line.group("path")
                lineno = match_line.group("lineno")
                rest = match_line.group("rest")
                icon = match_line.group("icon")

                # A line's context is defined by its parent's scope (depth - 1).
                parent_depth = depth - 1

                if parent_depth in path_info_at_depth:
                    parent_path, parent_path_len = path_info_at_depth[parent_depth]
                    # If the path is the same as the parent's, compress it.
                    if path == parent_path:
                        path_padding = " " * parent_path_len
                        print(f"{tabs}{icon} {path_padding}:{lineno}{rest}")
                    else:
                        # Path differs from parent context; this is unusual but
                        # we print the full line to be safe.
                        print(f"{tabs}{content}")
                else:
                    # No parent context found (e.g., trace starts mid-execution).
                    # Print the full line.
                    print(f"{tabs}{content}")

            # Other lines (RETURN, C-CALLS, etc.) are printed with indentation.
            # They don't contain paths in a way that can be compressed, but their
            # indentation change correctly terminates contexts for subsequent lines.
            else:
                print(f"{tabs}{content}")


def main() -> None:
    """Main entry point for the script."""
    parser = argparse.ArgumentParser(
        description="Compresses context-tracer text logs for LLM context.",
        formatter_class=argparse.RawTextHelpFormatter,
    )
    parser.add_argument(
        "input_file",
        type=Path,
        help="Path to the tracer text log file to process.",
    )
    args = parser.parse_args()
    process_log_file(args.input_file)


if __name__ == "__main__":
    main()
