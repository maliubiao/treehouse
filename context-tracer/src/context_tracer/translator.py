"""
Trace Data Container Translator

This module provides a command-line tool to read a trace data container file
(generated by the tracer with container support enabled) and translate it into
a human-readable format, such as an interactive HTML report or a plain text log.
"""

import argparse
import sys
import time
from pathlib import Path
from typing import Any, Dict, Optional, Tuple, cast

from .container import DataContainerReader, EventType, FileManager, TraceEvent
from .tracer import _INDENT, TraceConfig
from .tracer_common import TraceTypes
from .tracer_html import CallTreeHtmlRender


class Translator:
    """Reads a data container and translates its contents."""

    def __init__(self, container_path: Path, key: bytes):
        """
        Initializes the Translator.

        Args:
            container_path: Path to the data container file.
            key: The decryption key in bytes.
        """
        self._reader = DataContainerReader(container_path, key)
        self._file_manager: Optional[FileManager] = None

    def translate_to_html(self, output_path: Path) -> None:
        """
        Translates the container data into an interactive HTML report.

        Args:
            output_path: The path to save the generated HTML file.
        """
        print("Starting HTML translation...")
        start_time = time.time()

        self._reader.open()
        self._file_manager = self._reader.file_manager
        if not self._file_manager:
            raise RuntimeError("File manager not found in container.")

        # Pass a dummy config to the renderer, as it's only used for the title.
        # The translator doesn't have access to the original trace config.
        dummy_config = TraceConfig(report_name=output_path.name, container_key="00" * 16)
        renderer = CallTreeHtmlRender(config=dummy_config)

        event_count = 0
        for event in self._reader:
            log_data, color_type = self._event_to_log_data(event)
            renderer.add_raw_message(log_data, color_type)
            event_count += 1
            if event_count % 1000 == 0:
                print(f"Processed {event_count} events...", end="\r")

        renderer.save_to_file(str(output_path), is_multi_threaded=False)

        end_time = time.time()
        print(f"\nHTML report generated at: {output_path.resolve()}")
        print(f"Processed {event_count} events in {end_time - start_time:.2f} seconds.")

    def translate_to_text(self, output_path: Path) -> None:
        """
        Translates the container data into a plain text log file.

        Args:
            output_path: The path to save the generated text log.
        """
        print("Starting text translation...")
        start_time = time.time()

        self._reader.open()
        self._file_manager = self._reader.file_manager
        if not self._file_manager:
            raise RuntimeError("File manager not found in container.")

        event_count = 0
        stack_depth: Dict[int, int] = {}  # thread_id -> depth

        with open(output_path, "w", encoding="utf-8") as f:
            for event in self._reader:
                thread_id = event["thread_id"]
                depth = stack_depth.get(thread_id, 0)
                log_line = self._format_event_as_text(event, depth)
                f.write(f"{log_line}\n")

                # Update stack depth
                if event["event_type"] == EventType.CALL.value:
                    stack_depth[thread_id] = depth + 1
                elif event["event_type"] in (EventType.RETURN.value, EventType.EXCEPTION.value):
                    stack_depth[thread_id] = max(0, depth - 1)

                event_count += 1
                if event_count % 1000 == 0:
                    print(f"Processed {event_count} events...", end="\r")

        end_time = time.time()
        print(f"\nText log generated at: {output_path.resolve()}")
        print(f"Processed {event_count} events in {end_time - start_time:.2f} seconds.")

    def _event_to_log_data(self, event: TraceEvent) -> Tuple[Dict[str, Any], str]:
        """
        Converts a TraceEvent from the container back into the log_data dictionary
        format expected by the HTML renderer.
        """
        if not self._file_manager:
            raise RuntimeError("File manager must be initialized before converting events.")

        event_type = EventType(event["event_type"])
        data = event["data"]
        file_path = self._file_manager.get_path(event["file_id"]) or f"<unknown_file_{event['file_id']}>"
        depth = 0  # HTML renderer calculates indent from stack, not a fixed value here.
        log_data: Dict[str, Any]
        color_type: str

        common_data = {
            "indent": _INDENT * depth,
            "filename": file_path,
            "original_filename": file_path,
            "lineno": event["lineno"],
            "frame_id": event["frame_id"],
            "thread_id": event["thread_id"],
        }

        if event_type == EventType.CALL:
            color_type = TraceTypes.COLOR_CALL
            log_data = {
                "template": "{indent}↘ {prefix} {filename}:{lineno} {func}({args}) [frame:{frame_id}][thread:{thread_id}]",
                "data": {
                    **common_data,
                    "prefix": TraceTypes.PREFIX_CALL,
                    "func": data.get("func", "<unknown_func>"),
                    "args": data.get("args", ""),
                },
            }
        elif event_type == EventType.RETURN:
            color_type = TraceTypes.COLOR_RETURN
            log_data = {
                "template": "{indent}↗ {prefix} {filename} {func}() → {return_value} [frame:{frame_id}]",
                "data": {
                    **common_data,
                    "prefix": TraceTypes.PREFIX_RETURN,
                    "func": data.get("func", "<unknown_func>"),
                    "return_value": data.get("return_value", ""),
                },
            }
        elif event_type == EventType.EXCEPTION:
            color_type = TraceTypes.COLOR_EXCEPTION
            log_data = {
                "template": "{indent}⚠ {prefix} IN {func} AT {filename}:{lineno} {exc_type}: {exc_value} [frame:{frame_id}]",
                "data": {
                    **common_data,
                    "prefix": TraceTypes.PREFIX_EXCEPTION,
                    "func": data.get("func", "<unknown_func>"),
                    "exc_type": data.get("exc_type", "Exception"),
                    "exc_value": data.get("exc_value", ""),
                },
            }
        elif event_type == EventType.LINE:
            color_type = TraceTypes.COLOR_LINE
            # For simplicity in translation, we don't reconstruct multi-line statements here.
            # This would require re-parsing the source file. We'll show the single line.
            source_lines = self._file_manager.get_source_lines(event["file_id"])
            line_content = (
                source_lines[event["lineno"] - 1].strip()
                if source_lines and 0 <= event["lineno"] - 1 < len(source_lines)
                else "<source not available>"
            )
            tracked_vars = cast(Dict[str, str], data.get("tracked_vars", {}))
            vars_str = ", ".join(f"{k}={v}" for k, v in tracked_vars.items())

            template = "{indent}▷ {filename}:{lineno} {line}"
            if vars_str:
                template += " # Debug: {vars}"

            log_data = {
                "template": template,
                "data": {
                    **common_data,
                    "line": line_content,
                    "raw_line": line_content,
                    "tracked_vars": tracked_vars,
                    "vars": vars_str,
                },
            }
        else:
            # Handle C calls and other types as generic traces
            color_type = TraceTypes.COLOR_TRACE
            log_data = {
                "template": "{indent}ℹ {event_name} at {filename}:{lineno}",
                "data": {**common_data, "event_name": event_type.name},
            }

        return log_data, color_type

    def _format_event_as_text(self, event: TraceEvent, depth: int) -> str:
        """Formats a single trace event into a single line of text."""
        if not self._file_manager:
            return "[Error: File manager not initialized]"

        indent = "  " * depth
        event_type = EventType(event["event_type"])
        data = event["data"]
        file_path = self._file_manager.get_path(event["file_id"]) or f"<file_id_{event['file_id']}>"
        location = f"{file_path}:{event['lineno']}"

        if event_type == EventType.CALL:
            return f"{indent}CALL -> {data.get('func', '')}({data.get('args', '')}) at {location}"
        if event_type == EventType.RETURN:
            return f"{indent}RETURN <- {data.get('func', '')} -> {data.get('return_value', '')} at {location}"
        if event_type == EventType.EXCEPTION:
            exc_info = f"{data.get('exc_type', 'Exc')}: {data.get('exc_value', '')}"
            return f"{indent}EXCEPT! {exc_info} in {data.get('func', '')} at {location}"
        if event_type == EventType.LINE:
            vars_str = ""
            if data.get("tracked_vars"):
                vars_str = f" [vars: {data['tracked_vars']}]"
            return f"{indent}LINE -> {location}{vars_str}"
        return f"{indent}{event_type.name} -> {location}"


def main() -> None:
    """Command-line entry point for the translator."""
    parser = argparse.ArgumentParser(description="Translate context-tracer data container.")
    parser.add_argument("input_file", type=Path, help="Path to the .bin container file.")
    parser.add_argument("-k", "--key", required=True, help="Decryption key (hex string).")
    parser.add_argument(
        "-f",
        "--format",
        choices=["html", "text"],
        default="html",
        help="Output format (default: html).",
    )
    parser.add_argument(
        "-o",
        "--output",
        type=Path,
        help="Path to the output file (default: derived from input file).",
    )

    args = parser.parse_args()

    if not args.input_file or not args.input_file.exists():
        print(f"Error: Input file not found at {args.input_file}", file=sys.stderr)
        sys.exit(1)

    try:
        if not args.key:
            raise ValueError()
        key_bytes = bytes.fromhex(args.key)
        if len(key_bytes) not in [16, 24, 32]:
            raise ValueError()

        output_path = args.output
        if not output_path:
            ext = ".html" if args.format == "html" else ".log"
            output_path = args.input_file.with_suffix(ext)

        translator = Translator(args.input_file, key_bytes)
        if args.format == "html":
            translator.translate_to_html(output_path)
        elif args.format == "text":
            translator.translate_to_text(output_path)
    except Exception as e:
        print(f"An error occurred during translation: {e}", file=sys.stderr)
        import traceback

        traceback.print_exc()
        sys.exit(1)


if __name__ == "__main__":
    main()
