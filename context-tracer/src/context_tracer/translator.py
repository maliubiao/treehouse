"""
Trace Data Container Translator

This module provides a command-line tool to read a trace data container file
(generated by the tracer with container support enabled) and translate it into
a human-readable format, such as an interactive HTML report or a plain text log.
"""

import argparse
import sys
import time
from pathlib import Path
from typing import Any, Dict, Optional, Tuple, cast

from .container import (
    C_CALL_ARG0_INDEX,
    C_CALL_FUNC_INDEX,
    C_RAISE_FUNC_INDEX,
    C_RETURN_FUNC_INDEX,
    CALL_ARGS_INDEX,
    CALL_FUNC_INDEX,
    EXCEPTION_FUNC_INDEX,
    EXCEPTION_TYPE_INDEX,
    EXCEPTION_VALUE_INDEX,
    LINE_CONTENT_INDEX,
    LINE_RAW_INDEX,
    LINE_VARS_INDEX,
    RETURN_FUNC_INDEX,
    RETURN_VALUE_INDEX,
    RETURN_VARS_INDEX,
    DataContainerReader,
    EventType,
    FileManager,
    TraceEvent,
)
from .tracer import _INDENT, TraceConfig
from .tracer_common import TraceTypes
from .tracer_html import CallTreeHtmlRender


class Translator:
    """Reads a data container and translates its contents."""

    def __init__(self, container_path: Path, key: bytes):
        """
        Initializes the Translator.

        Args:
            container_path: Path to the data container file.
            key: The decryption key in bytes.
        """
        self._reader = DataContainerReader(container_path, key)
        self._file_manager: Optional[FileManager] = None

    def translate_to_html(self, output_path: Path) -> None:
        """
        Translates the container data into an interactive HTML report.

        Args:
            output_path: The path to save the generated HTML file.
        """
        print("Starting HTML translation...")
        start_time = time.time()

        self._reader.open()
        self._file_manager = self._reader.file_manager
        if not self._file_manager:
            raise RuntimeError("File manager not found in container.")

        # Pass a dummy config to the renderer, as it's only used for the title.
        # The translator doesn't have access to the original trace config.
        dummy_config = TraceConfig(report_name=output_path.name, container_key="00" * 16)
        renderer = CallTreeHtmlRender(config=dummy_config)

        event_count = 0
        for event in self._reader:
            log_data, color_type = self._event_to_log_data(event)
            renderer.add_raw_message(log_data, color_type)
            event_count += 1
            if event_count % 1000 == 0:
                print(f"Processed {event_count} events...", end="\r")

        # Convert relative paths to absolute paths before passing to save_to_file
        # This ensures the HTML renderer works correctly with paths containing directories
        if not output_path.is_absolute():
            output_path = output_path.resolve()

        final_output_path = renderer.save_to_file(str(output_path), is_multi_threaded=False)

        end_time = time.time()
        print(f"\nHTML report generated at: {final_output_path.resolve()}")
        print(f"Processed {event_count} events in {end_time - start_time:.2f} seconds.")

    def translate_to_text(self, output_path: Path) -> None:
        """
        Translates the container data into a plain text log file.

        Args:
            output_path: The path to save the generated text log.
        """
        print("Starting text translation...")
        start_time = time.time()

        self._reader.open()
        self._file_manager = self._reader.file_manager
        if not self._file_manager:
            raise RuntimeError("File manager not found in container.")

        event_count = 0
        stack_depth: Dict[int, int] = {}  # thread_id -> depth

        with open(output_path, "w", encoding="utf-8") as f:
            for event in self._reader:
                thread_id = event.thread_id
                depth = stack_depth.get(thread_id, 0)
                log_line = self._format_event_as_text(event, depth)
                f.write(f"{log_line}\n")

                # Update stack depth
                if event.event_type == EventType.CALL.value:
                    stack_depth[thread_id] = depth + 1
                elif event.event_type in (EventType.RETURN.value, EventType.EXCEPTION.value):
                    stack_depth[thread_id] = max(0, depth - 1)

                event_count += 1
                if event_count % 1000 == 0:
                    print(f"Processed {event_count} events...", end="\r")

        end_time = time.time()
        print(f"\nText log generated at: {output_path.resolve()}")
        print(f"Processed {event_count} events in {end_time - start_time:.2f} seconds.")

    def _event_to_log_data(self, event: TraceEvent) -> Tuple[Dict[str, Any], str]:
        """
        Converts a V3 TraceEvent (list-based) from the container back into the log_data dictionary
        format expected by the HTML renderer.
        """
        if not self._file_manager:
            raise RuntimeError("File manager must be initialized before converting events.")

        event_type = EventType(event.event_type)
        data_list = event.data  # Now a list instead of dict
        file_path = self._file_manager.get_path(event.file_id) or f"<unknown_file_{event.file_id}>"
        depth = 0  # HTML renderer calculates indent from stack, not a fixed value here.
        log_data: Dict[str, Any]
        color_type: str

        common_data = {
            "indent": _INDENT * depth,
            "filename": file_path,
            "original_filename": file_path,
            "lineno": event.lineno,
            "frame_id": event.frame_id,
            "thread_id": event.thread_id,
        }

        if event_type == EventType.CALL:
            # CALL: [func_name, args_str]
            color_type = TraceTypes.COLOR_CALL
            func_name = data_list[CALL_FUNC_INDEX] if len(data_list) > CALL_FUNC_INDEX else "<unknown_func>"
            args_str = data_list[CALL_ARGS_INDEX] if len(data_list) > CALL_ARGS_INDEX else ""
            log_data = {
                "template": "{indent}↘ {prefix} {filename}:{lineno} {func}({args}) [frame:{frame_id}][thread:{thread_id}]",
                "data": {
                    **common_data,
                    "prefix": TraceTypes.PREFIX_CALL,
                    "func": func_name,
                    "args": args_str,
                },
            }
        elif event_type == EventType.RETURN:
            # RETURN: [func_name, return_value_str, tracked_vars_list]
            color_type = TraceTypes.COLOR_RETURN
            func_name = data_list[RETURN_FUNC_INDEX] if len(data_list) > RETURN_FUNC_INDEX else "<unknown_func>"
            return_value = data_list[RETURN_VALUE_INDEX] if len(data_list) > RETURN_VALUE_INDEX else ""
            log_data = {
                "template": "{indent}↗ {prefix} {filename} {func}() → {return_value} [frame:{frame_id}]",
                "data": {
                    **common_data,
                    "prefix": TraceTypes.PREFIX_RETURN,
                    "func": func_name,
                    "return_value": return_value,
                },
            }
        elif event_type == EventType.EXCEPTION:
            # EXCEPTION: [func_name, exc_type_str, exc_value_str]
            color_type = TraceTypes.COLOR_EXCEPTION
            func_name = data_list[EXCEPTION_FUNC_INDEX] if len(data_list) > EXCEPTION_FUNC_INDEX else "<unknown_func>"
            exc_type_str = data_list[EXCEPTION_TYPE_INDEX] if len(data_list) > EXCEPTION_TYPE_INDEX else "Exception"
            exc_value_str = data_list[EXCEPTION_VALUE_INDEX] if len(data_list) > EXCEPTION_VALUE_INDEX else ""
            log_data = {
                "template": "{indent}⚠ {prefix} IN {func} AT {filename}:{lineno} {exc_type}: {exc_value} [frame:{frame_id}]",
                "data": {
                    **common_data,
                    "prefix": TraceTypes.PREFIX_EXCEPTION,
                    "func": func_name,
                    "exc_type": exc_type_str,
                    "exc_value": exc_value_str,
                },
            }
        elif event_type == EventType.LINE:
            # LINE: [line_content, raw_line, tracked_vars_list]
            color_type = TraceTypes.COLOR_LINE
            line_content = (
                data_list[LINE_CONTENT_INDEX] if len(data_list) > LINE_CONTENT_INDEX else "<source not available>"
            )
            raw_line = data_list[LINE_RAW_INDEX] if len(data_list) > LINE_RAW_INDEX else line_content
            tracked_vars_list = data_list[LINE_VARS_INDEX] if len(data_list) > LINE_VARS_INDEX else []

            # Convert tracked_vars_list back to dict format
            tracked_vars = {item[0]: item[1] for item in tracked_vars_list if len(item) >= 2}
            vars_str = ", ".join(f"{k}={v}" for k, v in tracked_vars.items())

            template = "{indent}▷ {filename}:{lineno} {line}"
            if vars_str:
                template += " # Debug: {vars}"

            log_data = {
                "template": template,
                "data": {
                    **common_data,
                    "line": line_content,
                    "raw_line": raw_line,
                    "tracked_vars": tracked_vars,
                    "vars": vars_str,
                },
            }
        else:
            # Handle C calls and other types
            color_type = TraceTypes.COLOR_TRACE
            if event_type == EventType.C_CALL:
                func_name = data_list[C_CALL_FUNC_INDEX] if len(data_list) > C_CALL_FUNC_INDEX else "<unknown_func>"
                arg0_str = data_list[C_CALL_ARG0_INDEX] if len(data_list) > C_CALL_ARG0_INDEX else ""
                template = (
                    "{indent}↘ C-CALL {func_name}({arg0}) at {filename}:{lineno} [frame:{frame_id}][thread:{thread_id}]"
                )
                log_data = {
                    "template": template,
                    "data": {**common_data, "func_name": func_name, "arg0": arg0_str},
                }
            elif event_type == EventType.C_RETURN:
                func_name = data_list[C_RETURN_FUNC_INDEX] if len(data_list) > C_RETURN_FUNC_INDEX else "<unknown_func>"
                template = "{indent}↗ C-RETURN from {func_name} [frame:{frame_id}][thread:{thread_id}]"
                log_data = {
                    "template": template,
                    "data": {**common_data, "func_name": func_name},
                }
            elif event_type == EventType.C_RAISE:
                func_name = data_list[C_RAISE_FUNC_INDEX] if len(data_list) > C_RAISE_FUNC_INDEX else "<unknown_func>"
                template = "{indent}⚠ C-RAISE from {func_name} [frame:{frame_id}][thread:{thread_id}]"
                log_data = {
                    "template": template,
                    "data": {**common_data, "func_name": func_name},
                }
            else:
                log_data = {
                    "template": "{indent}ℹ {event_name} at {filename}:{lineno}",
                    "data": {**common_data, "event_name": event_type.name},
                }

        return log_data, color_type

    def _format_event_as_text(self, event: TraceEvent, depth: int) -> str:
        """Formats a single V3 trace event (list-based) into a single line of text."""
        if not self._file_manager:
            return "[Error: File manager not initialized]"

        indent = "  " * depth
        event_type = EventType(event.event_type)
        data_list = event.data  # Now a list instead of dict
        file_path = self._file_manager.get_path(event.file_id) or f"<file_id_{event.file_id}>"
        location = f"{file_path}:{event.lineno}"

        if event_type == EventType.CALL:
            # CALL: [func_name, args_str]
            func_name = data_list[CALL_FUNC_INDEX] if len(data_list) > CALL_FUNC_INDEX else ""
            args_str = data_list[CALL_ARGS_INDEX] if len(data_list) > CALL_ARGS_INDEX else ""
            return f"{indent}CALL -> {func_name}({args_str}) at {location}"
        if event_type == EventType.RETURN:
            # RETURN: [func_name, return_value_str, tracked_vars_list]
            func_name = data_list[RETURN_FUNC_INDEX] if len(data_list) > RETURN_FUNC_INDEX else ""
            return_value = data_list[RETURN_VALUE_INDEX] if len(data_list) > RETURN_VALUE_INDEX else ""
            return f"{indent}RETURN <- {func_name} -> {return_value} at {location}"
        if event_type == EventType.EXCEPTION:
            # EXCEPTION: [func_name, exc_type_str, exc_value_str]
            func_name = data_list[EXCEPTION_FUNC_INDEX] if len(data_list) > EXCEPTION_FUNC_INDEX else ""
            exc_type_str = data_list[EXCEPTION_TYPE_INDEX] if len(data_list) > EXCEPTION_TYPE_INDEX else "Exc"
            exc_value_str = data_list[EXCEPTION_VALUE_INDEX] if len(data_list) > EXCEPTION_VALUE_INDEX else ""
            exc_info = f"{exc_type_str}: {exc_value_str}"
            return f"{indent}EXCEPT! {exc_info} in {func_name} at {location}"
        if event_type == EventType.LINE:
            # LINE: [line_content, raw_line, tracked_vars_list]
            vars_str = ""
            if len(data_list) > LINE_VARS_INDEX and data_list[LINE_VARS_INDEX]:  # tracked_vars_list
                tracked_vars = {item[0]: item[1] for item in data_list[LINE_VARS_INDEX] if len(item) >= 2}
                if tracked_vars:
                    vars_str = f" [vars: {tracked_vars}]"
            return f"{indent}LINE -> {location}{vars_str}"

        # Handle C calls
        if event_type in (EventType.C_CALL, EventType.C_RETURN, EventType.C_RAISE):
            func_name = data_list[0] if len(data_list) > 0 else ""
            return f"{indent}{event_type.name} -> {func_name} at {location}"

        return f"{indent}{event_type.name} -> {location}"


def _read_container_key_from_file(key_file_path: Path) -> str:
    """从文件读取容器密钥"""
    if not key_file_path.exists():
        raise FileNotFoundError(f"密钥文件不存在: {key_file_path}")

    with open(key_file_path, "r", encoding="utf-8") as f:
        content = f.read().strip()

    # 解析密钥文件格式: container_key=xxxxx
    for line in content.split("\n"):
        line = line.strip()
        if line.startswith("container_key="):
            key_hex = line.split("=", 1)[1]
            if not key_hex:
                raise ValueError(f"密钥文件中未找到有效的密钥: {key_file_path}")
            return key_hex

    raise ValueError(f"密钥文件格式错误，未找到 'container_key=' 行: {key_file_path}")


def main() -> None:
    """Command-line entry point for the translator."""
    parser = argparse.ArgumentParser(description="Translate context-tracer data container.")
    parser.add_argument("input_file", type=Path, help="Path to the .bin container file.")
    parser.add_argument("-k", "--key", help="Decryption key (hex string).")
    parser.add_argument("--key-file", type=Path, help="Read decryption key from file (alternative to --key).")
    parser.add_argument(
        "-f",
        "--format",
        choices=["html", "text"],
        default="html",
        help="Output format (default: html).",
    )
    parser.add_argument(
        "-o",
        "--output",
        type=Path,
        help="Path to the output file (default: derived from input file).",
    )

    args = parser.parse_args()

    if not args.input_file or not args.input_file.exists():
        print(f"Error: Input file not found at {args.input_file}", file=sys.stderr)
        sys.exit(1)

    # Check for key parameter conflicts
    if args.key and args.key_file:
        print("Error: Cannot specify both --key and --key-file. Please choose one method.", file=sys.stderr)
        sys.exit(1)

    # If no key method specified, try to find default key file
    if not args.key and not args.key_file:
        default_key_file = Path("tracer-logs/container_key.txt")
        if default_key_file.exists():
            print(f"No key specified, using default key file: {default_key_file}")
            args.key_file = default_key_file
        else:
            print("Error: Must specify either --key or --key-file for decryption.", file=sys.stderr)
            print(f"  (Or place key file at default location: {default_key_file})", file=sys.stderr)
            sys.exit(1)

    try:
        # Get the key either from direct input or from file
        if args.key_file:
            key_hex = _read_container_key_from_file(args.key_file)
        else:
            key_hex = args.key

        if not key_hex:
            raise ValueError("Empty key provided")

        key_bytes = bytes.fromhex(key_hex)
        if len(key_bytes) not in [16, 24, 32]:
            raise ValueError("Key must be 16, 24, or 32 bytes (32, 48, or 64 hex characters)")

        output_path = args.output
        if not output_path:
            ext = ".html" if args.format == "html" else ".log"
            output_path = args.input_file.with_suffix(ext)

        translator = Translator(args.input_file, key_bytes)
        if args.format == "html":
            translator.translate_to_html(output_path)
        elif args.format == "text":
            translator.translate_to_text(output_path)
    except Exception as e:
        print(f"An error occurred during translation: {e}", file=sys.stderr)
        import traceback

        traceback.print_exc()
        sys.exit(1)


if __name__ == "__main__":
    main()
