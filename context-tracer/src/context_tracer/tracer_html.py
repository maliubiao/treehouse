"""
HTML Report Renderer for Python Tracer.

This module provides the CallTreeHtmlRender class, which is responsible for
transforming raw trace data into an interactive and human-readable HTML report.
"""

import base64
import datetime
import dis
import html
import json
import logging
import shutil
from collections import defaultdict
from pathlib import Path
from typing import TYPE_CHECKING, Any, DefaultDict, Dict, List, Optional, Set, Tuple, Union

from .tracer_common import TraceTypes, truncate_repr_value

if TYPE_CHECKING:
    from .tracer import TraceLogic


class CallTreeHtmlRender:
    """
    Renders trace logs into a feature-rich HTML report.

    This class processes raw log messages generated by the tracer, formats them
    into HTML, and embeds them in a template that includes JavaScript for
    interactivity (e.g., searching, folding/unfolding call stacks, viewing source).

    Attributes:
        trace_logic (TraceLogic): The parent TraceLogic instance providing context.
        _messages (List[Tuple[str, str, Optional[Dict[str, Any]]]]): A list to store log messages.
            Each tuple contains the formatted message string, message type, and original log data.
        _executed_lines (DefaultDict[str, DefaultDict[int, Set[int]]]): A nested dictionary mapping
            `filename -> frame_id -> set of executed line numbers`.
        _source_files (Dict[str, str]): A cache for base64 encoded source file contents.
        _stack_variables (Dict[int, List[Tuple[int, Any, Any]]]): Maps a message index to its stack variables.
        _comments_data (DefaultDict[str, DefaultDict[int, List[str]]]): Maps filename and line number to comments.
        current_message_id (int): A counter for messages, used for unique IDs.
        _size_limit (int): The maximum size of the HTML report in bytes to prevent performance issues.
        _current_size (int): The current calculated size of the generated HTML content.
        _size_exceeded (bool): Flag indicating if the size limit has been reached.
        _html_template (str): The HTML template string for the final report.
    """

    def __init__(self, trace_logic: "TraceLogic"):
        """
        Initializes the CallTreeHtmlRender instance.

        Args:
            trace_logic: The parent TraceLogic instance that holds the trace configuration and state.
        """
        self.trace_logic: "TraceLogic" = trace_logic
        self._messages: List[Tuple[str, str, Optional[Dict[str, Any]]]] = []
        self._executed_lines: DefaultDict[str, DefaultDict[int, Set[int]]] = defaultdict(lambda: defaultdict(set))
        self._source_files: Dict[str, str] = {}
        self._stack_variables: Dict[int, List[Tuple[int, Any, Any]]] = {}
        self._comments_data: DefaultDict[str, DefaultDict[int, List[str]]] = defaultdict(lambda: defaultdict(list))
        self.current_message_id: int = 0
        self._size_limit: int = 1024 * 1024 * 1024  # 100 MB
        self._current_size: int = 0
        self._size_exceeded: bool = False
        self.line_comment: DefaultDict[str, List[Any]] = defaultdict(lambda: list())
        self._html_template: str = """
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>{title}</title>
            <link rel="stylesheet" href="../tracer_styles.css">
            <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css"
                rel="stylesheet" id="prism-theme">
            <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css"
                rel="stylesheet">
            <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.css"
                rel="stylesheet">
            <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
        </head>
        <body>
            <!-- App Container -->
            <div class="app-container">
                <!-- Sidebar -->
                <aside class="sidebar" id="sidebar">
                    <div class="sidebar-header">
                        <h2 class="sidebar-title" data-i18n="sidebarTraceExplorer">
                            <i class="fas fa-bug"></i> Trace Explorer
                        </h2>
                    </div>
                    <div class="sidebar-content">
                        <!-- Search -->
                        <div class="sidebar-section">
                            <input type="text" id="sidebarSearch" class="sidebar-search" 
                                   data-i18n-placeholder="searchPlaceholder" placeholder="Search messages...">
                        </div>

                        <!-- Filters -->
                        <div class="sidebar-section">
                            <h3 class="sidebar-section-title" data-i18n="filterByType">Filter by Type</h3>
                            <div class="filter-group">
                                <label class="filter-checkbox">
                                    <input type="checkbox" id="filterCall" checked>
                                    <span class="color-indicator" style="background-color: var(--call-color)"></span>
                                    <span data-i18n="calls">Calls</span>
                                </label>
                                <label class="filter-checkbox">
                                    <input type="checkbox" id="filterReturn" checked>
                                    <span class="color-indicator" style="background-color: var(--return-color)"></span>
                                    <span data-i18n="returns">Returns</span>
                                </label>
                                <label class="filter-checkbox">
                                    <input type="checkbox" id="filterLine" checked>
                                    <span class="color-indicator" style="background-color: var(--line-color)"></span>
                                    <span data-i18n="lines">Lines</span>
                                </label>
                                <label class="filter-checkbox">
                                    <input type="checkbox" id="filterException" checked>
                                    <span class="color-indicator" style="background-color: var(--error-color)"></span>
                                    <span data-i18n="exceptions">Exceptions</span>
                                </label>
                            </div>
                        </div>

                        <!-- Statistics -->
                        <div class="sidebar-section">
                            <h3 class="sidebar-section-title" data-i18n="statistics">Statistics</h3>
                            <div class="filter-stats">
                                <h3 data-i18n="summary">Summary</h3>
                                <p><span data-i18n="totalMessages">Total Messages</span>: <span class="stat-value">{message_count}</span></p>
                                <p><span data-i18n="errors">Errors</span>: <span class="stat-value">{error_count}</span></p>
                                <p><span data-i18n="generated">Generated</span>: <span class="stat-value">{generation_time}</span></p>
                            </div>
                        </div>

                        <!-- Quick Actions -->
                        <div class="sidebar-section">
                            <h3 class="sidebar-section-title" data-i18n="quickActions">Quick Actions</h3>
                            <button id="expandAll" style="width: 100%; margin-bottom: 0.5rem;" data-i18n-title="expandAllTitle" title="Expand all call stacks">
                                <i class="fas fa-expand-alt"></i> Expand All
                            </button>
                            <button id="collapseAll" style="width: 100%; margin-bottom: 0.5rem;" data-i18n-title="collapseAllTitle" title="Collapse all call stacks">
                                <i class="fas fa-compress-alt"></i> Collapse All
                            </button>
                            <button id="skeletonViewBtn" style="width: 100%;" data-i18n-title="skeletonViewTitle" title="Toggle skeleton view">
                                <i class="fas fa-code-branch"></i> Skeleton View
                            </button>
                        </div>
                    </div>
                </aside>

                <!-- Sidebar Overlay for Mobile -->
                <div class="sidebar-overlay" id="sidebarOverlay"></div>

                <!-- Main Content -->
                <main class="main-content">
                    <header class="main-header">
                        <button class="toggle-sidebar icon-btn" id="toggleSidebar" title="Toggle sidebar">
                            <i class="fas fa-bars"></i>
                        </button>
                        <h1 data-i18n="mainTitle">Python Trace Report</h1>
                        <nav id="controls" class="nav-controls">
                            <div class="dropdown-container">
                                <button id="summaryBtn" class="dropdown-toggle" title="Show summary">
                                    <i class="fas fa-chart-bar"></i>
                                </button>
                                <div id="summaryDropdown" class="dropdown-menu">
                                    <p><strong data-i18n="generatedAt">Generated at:</strong> {generation_time}</p>
                                    <p><strong data-i18n="totalMessages">Total messages:</strong> {message_count}</p>
                                    <p><strong data-i18n="errors">Errors:</strong> {error_count}</p>
                                </div>
                            </div>
                            <button id="settingsBtn" class="icon-btn" title="Settings">
                                <i class="fas fa-cog"></i>
                            </button>
                            <button id="exportBtn" class="icon-btn" title="Export as HTML">
                                <i class="fas fa-download"></i>
                            </button>
                        </nav>
                    </header>

                    <div class="content-wrapper">
                        <div id="content">{content}</div>
                    </div>
                </main>
            </div>

            <!-- Source Dialog -->
            <div id="sourceDialog" class="source-dialog" style="display: none;">
                <div class="floating-close-btn" id="dialogCloseBtn">&times;</div>
                <div class="close-overlay"></div>
                <div class="source-header">
                    <div class="source-title" id="sourceTitle"></div>
                </div>
                <div class="source-content" id="sourceContent"></div>
            </div>

            <!-- Settings Dialog -->
            <div id="settingsDialog" class="modal" style="display: none;">
                <div class="modal-content wide">
                    <span class="modal-close-btn">&times;</span>
                    <h2 data-i18n="settingsTitle">Settings</h2>
                    <div class="modal-tabs">
                        <button class="tab-link active" data-tab="tab-display" data-i18n="displayTab">Display</button>
                        <button class="tab-link" data-tab="tab-help" data-i18n="helpTab">Help</button>
                    </div>

                    <!-- Display Tab -->
                    <div id="tab-display" class="tab-content active">
                        <div class="setting-item">
                            <label for="languageSelector" data-i18n="languageLabel">Language:</label>
                            <select id="languageSelector">
                                <option value="en">English</option>
                                <option value="zh">简体中文</option>
                            </select>
                        </div>
                        <div class="setting-item">
                            <label for="themeSelector" data-i18n="themeLabel">Theme:</label>
                            <select id="themeSelector">
                                <!-- Options will be populated by JavaScript -->
                            </select>
                        </div>
                    </div>

                    <!-- Help Tab -->
                    <div id="tab-help" class="tab-content">
                        <h3 data-i18n="logEntrySymbolsTitle">Log Entry Symbols</h3>
                        <table>
                            <thead>
                                <tr>
                                    <th data-i18n="tableHeaderSymbol">Symbol</th>
                                    <th data-i18n="tableHeaderType">Type</th>
                                    <th data-i18n="tableHeaderDescription">Description</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr><td>↘ CALL</td><td data-i18n="typeFuncCall">Function Call</td><td data-i18n="descFuncCall">A function call, either within a traced file or to an external library.</td></tr>
                                <tr><td>↗ RETURN</td><td data-i18n="typeFuncReturn">Function Return</td><td data-i18n="descFuncReturn">The return from a function.</td></tr>
                                <tr><td>↘ C-CALL</td><td data-i18n="typeCCall">C Function Call</td><td data-i18n="descCCall">(Python 3.12+) A direct call to a C-language function or builtin.</td></tr>
                                <tr><td>↗ C-RETURN</td><td data-i18n="typeCReturn">C Function Return</td><td data-i18n="descCReturn">(Python 3.12+) The return from a C function call.</td></tr>
                                <tr><td>⚠ C-RAISE</td><td data-i18n="typeCRaise">C Function Raise</td><td data-i18n="descCRaise">(Python 3.12+) An exception raised from within a C function.</td></tr>
                                <tr><td>▷ LINE</td><td data-i18n="typeLineExec">Line Execution</td><td data-i18n="descLineExec">A line of source code that was executed.</td></tr>
                                <tr><td>⚠ EXCEPTION</td><td data-i18n="typeException">Exception</td><td data-i18n="descException">An exception that occurred within a function.</td></tr>
                                <tr><td>↳ Debug</td><td data-i18n="typeDebugStmt">Debug Statement</td><td data-i18n="descDebugStmt">The result of a special <code># trace: expression</code> comment.</td></tr>
                            </tbody>
                        </table>
                        <h3 data-i18n="interactiveFeaturesTitle">Interactive Features</h3>
                        <ul>
                            <li data-i18n="featureFolding"><strong>Folding:</strong> Click on any <code>CALL</code> entry to expand or collapse its entire call stack.</li>
                            <li data-i18n="featureViewSource"><strong>View Source:</strong> Hover over a log entry and click 'view source' to see the source code with executed lines highlighted.</li>
                            <li data-i18n="featureCopySubtree"><strong>Copy Subtree (📋):</strong> Copies the text of a complete call subtree (from CALL to RETURN) to the clipboard.</li>
                            <li data-i18n="featureFocusSubtree"><strong>Focus Subtree (🔍):</strong> Opens a new window showing only the selected call subtree.</li>
                            <li data-i18n="featureExplainAI"><strong>Explain with AI (🤖):</strong> Sends the selected subtree to a Large Language Model for an explanation (requires a running LLM API).</li>
                        </ul>
                    </div>
                </div>
            </div>

            <!-- AI Explain Dialog -->
            <div id="aiExplainDialog" class="ai-explain-dialog" style="display: none;">
                <div class="ai-explain-dialog-content">
                    <div class="ai-explain-header">
                        <h2 data-i18n="aiDialogTitle">🤖 AI Code Trace Explanation</h2>
                        <span class="ai-explain-close-btn">&times;</span>
                    </div>
                    <div class="ai-explain-config">
                        <label for="llmApiUrl" data-i18n="aiApiUrlLabel">LLM API URL:</label>
                        <input type="text" id="llmApiUrl" data-i18n-placeholder="aiApiUrlPlaceholder" placeholder="e.g., http://127.0.0.1:8000">
                        <label for="llmModelSelect" data-i18n="aiModelLabel">Model:</label>
                        <select id="llmModelSelect"></select>
                        <button id="llmSettingsSaveBtn" data-i18n="aiSaveBtn">Save</button>
                        <button id="llmFetchModelsBtn" data-i18n="aiRefreshModelsBtn">Refresh Models</button>
                    </div>
                    <div class="ai-explain-body" id="aiExplainBody">
                        <!-- Log content will be injected here -->
                    </div>

                    <!-- Raw LLM Response Viewer -->
                    <div class="llm-raw-response-viewer">
                        <div class="llm-raw-response-header">
                            <span data-i18n="aiRawResponseTitle">LLM Raw Response (for diagnosis)</span>
                            <button id="llmRawResponseToggleBtn" data-i18n="aiShowBtn">Show</button>
                        </div>
                        <div class="llm-raw-response-content" id="llmRawResponseContent" style="display: none;">
                            <div class="llm-panel">
                                <h4 data-i18n="aiThinkingPanel">Thinking</h4>
                                <pre id="llmThinkingOutput"></pre>
                            </div>
                            <div class="llm-panel">
                                <h4 data-i18n="aiContentPanel">Content</h4>
                                <pre id="llmContentOutput"></pre>
                            </div>
                        </div>
                    </div>

                    <div class="ai-explain-footer">
                        <button id="startAiExplainBtn" data-i18n="aiStartExplanationBtn">Start Explanation</button>
                        <span id="aiExplainStatus"></span>
                    </div>
                </div>
            </div>

            <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
            <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
            <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
            <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.js"></script>
            <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js"></script>
            <script src="../tracer_scripts.js"></script>
            <script>
                window.executedLines = {executed_lines_data};
                window.sourceFiles = {source_files_data};
                window.commentsData = {comments_data};
                window.lineComment = {line_comment};
            </script>
        </body>
        </html>
        """

    def format_stack_variables(self, variables: List[Tuple[int, Any, Any]]) -> str:
        """
        Formats a list of stack variables into a compact string representation.

        Args:
            variables: A list of tuples, each containing (opcode, variable_name, value).

        Returns:
            A space-separated string of formatted variables.
        """
        if not variables:
            return ""
        text: List[str] = []
        seen: Set[str] = set()
        for opcode, var_name, value in variables:
            item: str = ""
            if "CALL" == dis.opname[opcode]:
                is_method = value[-1]
                value = value[:-1]
                instance_name = ""
                if is_method:
                    instance = value[0]
                    if getattr(instance, "__name__", None):
                        instance_name = instance.__name__
                    elif getattr(instance, "__class__", None):
                        instance_name = instance.__class__.__name__
                    else:
                        instance_name = repr(instance)
                    value = value[1:]
                args = ", ".join(f"{truncate_repr_value(arg)}" for arg in value)
                if getattr(var_name, "__code__", None):
                    item = f"{var_name.__code__.co_name}({args})"
                elif getattr(var_name, "__name__", None):
                    item = f"{var_name.__name__}({args})"
                else:
                    item = f"{var_name}({args})"
                if instance_name:
                    item = f"{instance_name}.{item}"
            elif "STORE_SUBSCR" == dis.opname[opcode]:
                item = f"[{var_name}]={truncate_repr_value(value)}"
            else:
                item = f"{var_name}={truncate_repr_value(value)}"
            if item not in seen:
                seen.add(item)
                text.append(item)
        return " ".join(text)

    def _message_to_html(self, message: str, msg_type: str, log_data: Optional[Dict[str, Any]]) -> str:
        """
        Converts a single log message into an HTML fragment.

        Args:
            message: The formatted log message string.
            msg_type: The type of the message (e.g., 'call', 'return').
            log_data: The raw dictionary of data associated with the log message.

        Returns:
            An HTML string representing the log message.
        """
        stripped_message = message.lstrip()
        indent = len(message) - len(stripped_message)
        data: Dict[str, Any] = log_data.get("data", {}) if isinstance(log_data, dict) else {}

        # --- Handle special rendering for LINE events ---
        is_multiline_stmt = False
        debug_vars_html = ""
        if msg_type == TraceTypes.COLOR_LINE and log_data and isinstance(log_data, dict):
            raw_line = data.get("raw_line", "")
            if "\n" in raw_line:
                is_multiline_stmt = True
            tracked_vars = data.get("tracked_vars")
            if tracked_vars:
                debug_vars_html = self._build_debug_vars_html(tracked_vars)
                # Remove text version from main message for HTML view
                debug_part_str = " # Debug: "
                if debug_part_str in stripped_message:
                    stripped_message = stripped_message.split(debug_part_str, 1)[0]

        if is_multiline_stmt:
            indented_statement = data.get("line", "")
            first_line_of_indented = indented_statement.splitlines()[0]
            prefix = stripped_message.split(first_line_of_indented, 1)[0]
            raw_statement = data.get("raw_line", "")

            # To prevent whitespace collapse in HTML, replace spaces with &nbsp;
            # This ensures both the prefix and the code line's own indentation are preserved.
            escaped_prefix_nbsp = html.escape(prefix).replace(" ", "&nbsp;")
            escaped_first_line_nbsp = html.escape(first_line_of_indented).replace(" ", "&nbsp;")
            escaped_raw_statement = html.escape(raw_statement)

            escaped_content = f"""<div class="multi-line-container">
                <span class="code-preview">{escaped_prefix_nbsp}{escaped_first_line_nbsp}... </span><span class="expand-code-btn" data-i18n-title="expandCodeTitle" title="Toggle view">[+]</span>
                <div class="code-full">
                    <span class="multi-line-prefix">{escaped_prefix_nbsp}</span>
                    <pre class="language-python"><code>{escaped_raw_statement}</code></pre>
                </div>
            </div>"""
        else:
            escaped_content = html.escape(stripped_message).replace(" ", "&nbsp;")

        original_filename: Optional[str] = data.get("original_filename")
        line_number: Optional[int] = data.get("lineno")
        frame_id: Optional[int] = data.get("frame_id")
        comment_html = ""
        idx: Optional[int] = log_data.get("idx") if isinstance(log_data, dict) else None
        if idx is not None and self._stack_variables.get(idx):
            comment = self.format_stack_variables(self._stack_variables[idx])
            comment_id = f"comment_{idx}"
            comment_html = self._build_comment_html(comment_id, comment) if comment else ""

        view_source_html = self._build_view_source_html(original_filename, line_number, frame_id)

        data_indent_attr = f'data-indent="{indent}"'
        actions_html = ""
        if msg_type == TraceTypes.COLOR_CALL:
            copy_subtree_html = ' <span class="copy-subtree-btn" data-i18n-title="copySubtreeTitle" title="Copy subtree as text">📋</span>'
            focus_subtree_html = ' <span class="focus-subtree-btn" data-i18n-title="focusSubtreeTitle" title="Focus on this subtree (crop)">🔍</span>'
            # New AI Explain button
            explain_ai_html = (
                ' <span class="explain-ai-btn" data-i18n-title="explainAITitle" title="Explain with AI">🤖</span>'
            )
            toggle_details_html = ' <span class="toggle-details-btn" data-i18n-title="toggleDetailsTitle" title="Show details for this subtree">👁️</span>'
            actions_html = copy_subtree_html + focus_subtree_html + explain_ai_html + toggle_details_html

        # Combine all parts to be appended after the main content
        appended_html = f"{view_source_html}{comment_html}{debug_vars_html}{actions_html}"

        html_parts: List[str] = []
        if msg_type == TraceTypes.COLOR_CALL:
            html_parts.extend(
                [
                    f'<div class="foldable {TraceTypes.HTML_CALL}" {data_indent_attr} style="--indent-space: {indent}ch;">',
                    f"    {escaped_content}{appended_html}",
                    "</div>",
                    '<div class="call-group collapsed">',
                ]
            )
        elif msg_type == TraceTypes.COLOR_RETURN:
            html_parts.extend(
                [
                    "</div>",
                    f'<div class="{TraceTypes.HTML_RETURN}" {data_indent_attr} style="padding-left:{indent}ch">',
                    f"    {escaped_content}{appended_html}",
                    "</div>",
                ]
            )
        elif msg_type in (TraceTypes.ERROR, TraceTypes.EXCEPTION, TraceTypes.COLOR_EXCEPTION):
            html_parts.extend(
                [
                    "</div>",
                    f'<div class="{TraceTypes.HTML_ERROR}" {data_indent_attr} style="padding-left:{indent}ch">',
                    f"    {escaped_content}{appended_html}",
                    "</div>",
                ]
            )
        else:
            html_parts.extend(
                [
                    f'<div class="{msg_type}" {data_indent_attr} style="padding-left:{indent}ch">',
                    f"    {escaped_content}{appended_html}",
                    "</div>",
                ]
            )
        html_content = "\n".join(html_parts)
        self._current_size += len(html_content)
        if self._current_size > self._size_limit and not self._size_exceeded:
            self._size_exceeded = True
            size_limit_mb = self._size_limit / (1024 * 1024)
            return f'<div class="{TraceTypes.HTML_ERROR}">⚠ HTML报告大小已超过{size_limit_mb}MB限制，后续内容将被忽略</div>\n'
        return html_content

    def _build_debug_vars_html(self, variables: Dict[str, str]) -> str:
        """
        Builds the HTML for the interactive debug variables UI.

        Args:
            variables: A dictionary of variable names to their string representations.

        Returns:
            An HTML string for the debug variables container.
        """
        if not variables:
            return ""

        # 1. Generate compact view HTML
        compact_items_html = []
        for name, value in variables.items():
            escaped_name = html.escape(name)
            escaped_value = html.escape(value)
            compact_items_html.append(
                f'<span class="var-name">{escaped_name}</span>=<span class="var-value">{escaped_value}</span>'
            )
        compact_view_html = f'<div class="compact-view">{" ".join(compact_items_html)}</div>'

        # 2. Generate list view HTML
        list_items_html = []
        for name, value in variables.items():
            escaped_name = html.escape(name)
            # Use <pre> for value to preserve formatting
            escaped_value = f"<pre>{html.escape(value)}</pre>"
            list_items_html.append(
                f'<div class="var-entry"><span class="var-name">{escaped_name}</span>: <span class="var-value">{escaped_value}</span></div>'
            )
        list_view_html = f'<div class="list-view">{"".join(list_items_html)}</div>'

        # 3. Combine into the final container
        return f"""<div class="debug-vars" data-i18n-title="debugVarsTitle" title="Click to expand/collapse">
            {compact_view_html}
            {list_view_html}
        </div>"""

    def _build_comment_html(self, comment_id: str, comment: str) -> str:
        """
        Builds the HTML for a collapsible comment.

        Args:
            comment_id: The unique ID for the comment's HTML element.
            comment: The full text content of the comment.

        Returns:
            An HTML string for the comment span.
        """
        is_long = len(comment) > 64
        short_comment = comment[:64] + "..." if is_long else comment
        short_comment_escaped = html.escape(short_comment)
        full_comment_escaped = html.escape(comment)
        return f'''<span class="comment" id="{comment_id}" 
onclick="event.stopPropagation(); toggleCommentExpand('{comment_id}', event)">
<span class="comment-preview">{short_comment_escaped}</span>
<span class="comment-full">{full_comment_escaped}</span></span>'''

    def _build_view_source_html(
        self, filename: Optional[str], line_number: Optional[int], frame_id: Optional[int]
    ) -> str:
        """
        Builds the HTML for a 'view source' button.

        Args:
            filename: The path to the source file.
            line_number: The line number to highlight.
            frame_id: The ID of the frame to associate with the source view.

        Returns:
            An HTML string for the button, or an empty string if data is missing.
        """
        if not filename or not line_number or frame_id is None:
            return ""
        # Escape backslashes in filenames (important for Windows paths)
        escaped_filename = filename.replace("\\", "\\\\").replace("'", "\\'")
        return f'<span class="view-source-btn" onclick="showSource(\'{escaped_filename}\', {line_number}, {frame_id})" data-i18n="viewSource">view source</span>'

    def _load_source_file(self, filename: str) -> None:
        """
        Loads source file content and stores it in a base64 encoded format.

        If the file is already loaded, it does nothing.

        Args:
            filename: The path to the source file.
        """
        if filename in self._source_files:
            return
        try:
            with open(filename, "rb") as f:
                content: str = base64.b64encode(f.read()).decode("utf-8")
                self._source_files[filename] = content
        except (IOError, OSError) as e:
            self._source_files[filename] = f"// Error loading source file: {str(e)}"

    def add_message(self, message: str, msg_type: str, log_data: Optional[Dict[str, Any]] = None) -> None:
        """
        Adds a pre-formatted message to the internal message list.

        Args:
            message: The formatted message string.
            msg_type: The category of the message (e.g., call, return).
            log_data: The associated raw log data dictionary.
        """
        if self._size_exceeded:
            return
        self._messages.append((message, msg_type, log_data))

    def add_stack_variable_create(self, idx: int, opcode: int, var_name: Any, value: Any) -> None:
        """
        Records a stack variable creation event for a specific message.

        Args:
            idx: The index of the message this variable is associated with.
            opcode: The bytecode operation code.
            var_name: The name of the variable.
            value: The value of the variable.
        """
        if self._size_exceeded:
            return
        if idx not in self._stack_variables:
            self._stack_variables[idx] = []
        self._stack_variables[idx].append((opcode, var_name, value))

    def add_raw_message(self, log_data: Union[str, Dict[str, Any]], color_type: str) -> None:
        """
        Adds a raw log data object and processes it for HTML rendering.

        This method formats the log data, tracks executed lines, loads source
        code, and appends the result to the message list.

        Args:
            log_data: The raw log data, which can be a string or a dictionary.
            color_type: The color/type category for the message.
        """
        if self._size_exceeded:
            return

        if isinstance(log_data, str):
            message = log_data
        else:
            # Pre-format the message to avoid duplicate formatting.
            message = log_data["template"].format(**log_data["data"])
        if color_type == TraceTypes.COLOR_LINE and isinstance(log_data, dict) and "lineno" in log_data.get("data", {}):
            data: Dict[str, Any] = log_data["data"]
            original_filename: Optional[str] = data.get("original_filename")
            lineno: Optional[int] = data.get("lineno")
            frame_id: Optional[int] = data.get("frame_id")
            if data.get("tracked_vars"):
                self.line_comment[f"{frame_id}-{original_filename}-{lineno}"] = data["tracked_vars"]
            if original_filename and lineno is not None and frame_id is not None:
                self._executed_lines[original_filename][frame_id].add(lineno)
                self._load_source_file(original_filename)

        self._messages.append((message, color_type, log_data))

    def generate_html(self) -> str:
        """
        Generates the final, complete HTML report.

        This method iterates through all collected messages, converts them to HTML,
        and injects the result, along with metadata and supporting data (like
        executed lines and source files), into the main HTML template.

        Returns:
            A string containing the full HTML report.
        """
        buffer: List[str] = []
        error_count: int = 0
        frame_indents: Dict[int, int] = {}
        for _idx, (message, msg_type, log_data) in enumerate(self._messages):
            if self._size_exceeded and msg_type not in (
                TraceTypes.ERROR,
                TraceTypes.EXCEPTION,
                TraceTypes.COLOR_EXCEPTION,
            ):
                continue

            # --- Indentation Correction Logic ---
            original_indent = len(message) - len(message.lstrip())
            corrected_indent = original_indent

            frame_id: Optional[int] = None
            if isinstance(log_data, dict):
                data = log_data.get("data")
                if isinstance(data, dict):
                    frame_id = data.get("frame_id")

            if frame_id is not None:
                if frame_id not in frame_indents:
                    # First time seeing this frame, store its indent. Assumes the CALL event is first.
                    frame_indents[frame_id] = original_indent
                # Always use the stored indent for consistency.
                corrected_indent = frame_indents[frame_id]

            # Reconstruct the message with the corrected indentation for rendering.
            corrected_message = " " * corrected_indent + message.lstrip()

            buffer.append(self._message_to_html(corrected_message, msg_type, log_data))

            if msg_type in (TraceTypes.ERROR, TraceTypes.EXCEPTION, TraceTypes.COLOR_EXCEPTION):
                error_count += 1

        title: str
        try:
            # Defensively access config attributes to create a dynamic title
            config = getattr(self.trace_logic, "config", None)
            target_script: Optional[Path] = getattr(config, "target_script", None)
            target_module: Optional[str] = getattr(config, "target_module", None)

            if target_script and isinstance(target_script, Path):
                title = f"Trace Report for {target_script.name}"
            elif target_module:
                title = f"Trace Report for module {target_module}"
            else:
                title = "Python Trace Report"
        except Exception:
            # Ultimate fallback in case of any unexpected errors
            title = "Python Trace Report"

        generation_time = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        executed_lines_data: Dict[str, Dict[int, List[int]]] = {
            filename: {frame_id: list(lines) for frame_id, lines in frames.items()}
            for filename, frames in self._executed_lines.items()
        }
        executed_lines_json: str = json.dumps(executed_lines_data)
        source_files_json: str = json.dumps(self._source_files)
        comments_json: str = json.dumps(self._comments_data)
        line_comment_json: str = json.dumps(self.line_comment)

        return self._html_template.format(
            title=title,
            generation_time=generation_time,
            message_count=len(self._messages),
            error_count=error_count,
            content="".join(buffer),
            executed_lines_data=executed_lines_json,
            source_files_data=source_files_json,
            comments_data=comments_json,
            line_comment=line_comment_json,
        )

    def save_to_file(self, filename: str, is_multi_threaded: bool) -> Path:
        """
        Saves the generated HTML report to a file.

        If the trace was multi-threaded, it creates a self-contained directory
        with the HTML report and its CSS/JS assets. Otherwise, it saves a single
        HTML file and its assets to the main log directory, making it self-contained.

        Args:
            filename: The base name for the report file (e.g., "report.html").
            is_multi_threaded: True if the trace captured multiple threads.

        Returns:
            The Path object pointing to the final saved HTML file.
        """
        report_dir: Path = Path.cwd() / "tracer-logs"
        report_dir.mkdir(exist_ok=True)
        html_content: str = self.generate_html()

        output_dir: Path
        final_report_path: Path
        if is_multi_threaded:
            timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
            dir_name = f"{Path(filename).stem}_{timestamp}"
            output_dir = report_dir / dir_name
            output_dir.mkdir(exist_ok=True)
            final_report_path = output_dir / "report.html"
        else:
            output_dir = report_dir
            final_report_path = output_dir / filename

        # Copy asset files to the output directory
        try:
            asset_dir: Path = Path(__file__).parent
            assets: List[str] = ["tracer_styles.css", "tracer_scripts.js"]
            for asset in assets:
                source_asset = asset_dir / asset
                if source_asset.exists():
                    shutil.copy(source_asset, output_dir / asset)

            # Adjust asset paths in HTML to be relative to the output directory
            # This makes the report self-contained.
            html_content = html_content.replace('href="../tracer_styles.css"', 'href="tracer_styles.css"')
            html_content = html_content.replace('src="../tracer_scripts.js"', 'src="tracer_scripts.js"')
        except Exception as e:
            logging.error(f"无法复制资源文件: {e}")
            print(f"ERROR: 无法复制资源文件: {e}")

        final_report_path.write_text(html_content, encoding="utf-8")
        print(f"正在生成HTML报告 {final_report_path} ...")
        return final_report_path
