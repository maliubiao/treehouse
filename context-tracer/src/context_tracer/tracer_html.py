"""
HTML Report Renderer for Python Tracer.

This module provides the CallTreeHtmlRender class, which is responsible for
transforming raw trace data into an interactive and human-readable HTML report.
"""

import base64
import datetime
import dis
import html
import json
import logging
import os
import re
import shutil
from collections import defaultdict
from pathlib import Path
from typing import TYPE_CHECKING, Any, DefaultDict, Dict, List, Optional, Set, Tuple, Union

from .tracer_common import TraceTypes, truncate_repr_value

if TYPE_CHECKING:
    from .tracer import TraceConfig, TraceLogic


class CallTreeHtmlRender:
    """
    Renders trace logs into a feature-rich HTML report.

    This class processes raw log messages generated by the tracer, formats them
    into HTML, and embeds them in a template that includes JavaScript for
    interactivity (e.g., searching, folding/unfolding call stacks, viewing source).
    """

    def __init__(self, trace_logic: Optional["TraceLogic"] = None, config: Optional["TraceConfig"] = None):
        """
        Initializes the CallTreeHtmlRender instance.

        Args:
            trace_logic: The parent TraceLogic instance. (Legacy, for backward compatibility)
            config: A TraceConfig object. If provided, it is used directly.
                    If not, it's retrieved from trace_logic.
        """
        if config:
            self.config = config
        elif trace_logic:
            self.config = trace_logic.config
        else:
            # Create a default minimal config if none provided
            self.config = None

        self._messages: List[Tuple[str, str, Optional[Dict[str, Any]]]] = []
        self._executed_lines: DefaultDict[str, DefaultDict[int, Set[int]]] = defaultdict(lambda: defaultdict(set))
        self._source_files: Dict[str, str] = {}
        self._stack_variables: Dict[int, List[Tuple[int, Any, Any]]] = {}
        self._comments_data: DefaultDict[str, DefaultDict[int, List[str]]] = defaultdict(lambda: defaultdict(list))
        self.current_message_id: int = 0
        self._size_limit: int = 1024 * 1024 * 1024  # 100 MB
        self._current_size: int = 0
        self._size_exceeded: bool = False
        self.line_comment: DefaultDict[str, List[Any]] = defaultdict(lambda: list())
        self._event_metadata: Dict[int, Dict[str, Any]] = {}
        self._next_event_id: int = 1
        self._last_frame_info: Dict[int, Tuple[str, str, int]] = {}
        self._last_line_event_filename: Optional[str] = None
        self._last_event_type: Optional[str] = None  # Tracks the type of the last processed event
        self.default_lang: str = "zh"

        # Load template and translation files
        self._template: str = self._load_template("tracer_template.html")
        self._translations: Dict[str, Any] = self._load_translations("translations.json")

    def _load_template(self, filename: str) -> str:
        """Loads the HTML template file."""
        template_path = Path(__file__).parent / filename
        try:
            return template_path.read_text("utf-8")
        except FileNotFoundError:
            logging.error(f"Template file not found: {template_path}")
            return "<html><body><h1>Template file not found</h1></body></html>"

    def _load_translations(self, filename: str) -> Dict[str, Any]:
        """Loads the JSON translation file."""
        translations_path = Path(__file__).parent / filename
        try:
            with translations_path.open("r", encoding="utf-8") as f:
                return json.load(f)
        except (FileNotFoundError, json.JSONDecodeError) as e:
            logging.error(f"Failed to load translations file {translations_path}: {e}")
            return {}

    def _render_i18n(self, html_content: str, lang: str) -> str:
        """
        Renders internationalization tags in the HTML content.
        This function replaces `data-i18n` attributes with translated text.
        """
        if not self._translations:
            return html_content

        def replace_content(match: re.Match[str]) -> str:
            full_tag, tag_name, attributes, content = match.groups()
            key = re.search(r'data-i18n="([^"]+)"', attributes)
            if not key:
                return full_tag
            translation = self._translations.get(key.group(1), {}).get(lang)
            return f"<{tag_name} {attributes}>{translation or content.strip()}</{tag_name}>"

        def replace_attribute(attr_name: str, new_value: str, tag_attributes: str) -> str:
            pattern = re.compile(rf'{attr_name}="[^"]*"')
            if pattern.search(tag_attributes):
                return pattern.sub(f'{attr_name}="{html.escape(new_value)}"', tag_attributes)
            return f'{tag_attributes} {attr_name}="{html.escape(new_value)}"'

        # Pattern to find tags with data-i18n attributes
        # This will find any tag that has a data-i18n, data-i18n-placeholder, or data-i18n-title attribute.
        pattern = re.compile(
            r"<([a-zA-Z0-9]+)((?:\s+[a-zA-Z0-9_-]+(?:=(?P<quote>[\"'])(?:(?!(?P=quote)).)*(?P=quote))?)*\s+data-i18n-.*?)>"
        )

        def replace_all_i18n(match: re.Match[str]) -> str:
            tag = match.group(0)
            original_tag = tag

            # Handle data-i18n for inner content
            content_key_match = re.search(r'data-i18n="([^"]+)"', tag)
            if content_key_match:
                key = content_key_match.group(1)
                translation = self._translations.get(key, {}).get(lang)
                if translation:
                    # This is for tags that have their content replaced
                    # e.g., <span data-i18n="key">Default</span> -> <span data-i18n="key">Translated</span>
                    # We need to find the closing tag and replace the content.
                    # This regex is complex, so for now we'll only handle simple cases or rely on JS for dynamic ones
                    # A better approach is to handle this more carefully.
                    # Let's find the closing tag and replace content.
                    tag_name = re.match(r"<([a-zA-Z0-9]+)", tag).group(1)
                    # For self-closing tags, this won't work. Assuming non-self-closing.
                    # This is getting complicated. The simpler way is to do it in steps.
                    pass  # We will do a separate pass for content.

            # Handle placeholder
            placeholder_match = re.search(r'data-i18n-placeholder="([^"]+)"', tag)
            if placeholder_match:
                key = placeholder_match.group(1)
                translation = self._translations.get(key, {}).get(lang)
                if translation:
                    tag = tag.replace(placeholder_match.group(0), "")
                    tag = replace_attribute("placeholder", translation, tag)

            # Handle title
            title_match = re.search(r'data-i18n-title="([^"]+)"', tag)
            if title_match:
                key = title_match.group(1)
                translation = self._translations.get(key, {}).get(lang)
                if translation:
                    tag = tag.replace(title_match.group(0), "")
                    tag = replace_attribute("title", translation, tag)

            return tag

        # This logic is simpler and more robust
        # 1. Replace attributes (placeholder, title)
        def replace_attrs(content: str) -> str:
            for key, translations in self._translations.items():
                translation = translations.get(lang)
                if translation:
                    # Placeholder
                    content = re.sub(
                        rf'(<[^>]*\s)data-i18n-placeholder="{key}"([^>]*placeholder="[^"]*")',
                        rf"\1\2",
                        content,
                    )
                    content = re.sub(
                        rf'(data-i18n-placeholder="{key}")([^>]*>)',
                        rf'placeholder="{html.escape(translation)}"\2',
                        content,
                    )
                    # Title
                    content = re.sub(
                        rf'(<[^>]*\s)data-i18n-title="{key}"([^>]*title="[^"]*")',
                        rf"\1\2",
                        content,
                    )
                    content = re.sub(
                        rf'(data-i18n-title="{key}")([^>]*>)',
                        rf'title="{html.escape(translation)}"\2',
                        content,
                    )
            return content

        # 2. Replace innerHTML content
        def replace_innerHTML(content: str) -> str:
            for key, translations in self._translations.items():
                translation = translations.get(lang)
                if translation:
                    # A more robust regex that finds a tag with data-i18n, captures the tag name,
                    # and replaces its content until its closing tag.
                    # This is not a full HTML parser but handles the simple structures in the template.
                    pattern = re.compile(
                        rf'(<([a-zA-Z0-9]+)[^>]*data-i18n="{key}"[^>]*>)(.*?)(</\2>)',
                        re.DOTALL | re.IGNORECASE,
                    )
                    content = pattern.sub(rf"\1{translation}\4", content)
            return content

        html_content = replace_attrs(html_content)
        html_content = replace_innerHTML(html_content)
        # Set the root language
        html_content = re.sub(r'<html lang="[^"]*">', f'<html lang="{lang}">', html_content)

        return html_content

    def format_stack_variables(self, variables: List[Tuple[int, Any, Any]]) -> str:
        """Formats a list of stack variables into a compact string representation."""
        if not variables:
            return ""
        text: List[str] = []
        seen: Set[str] = set()
        for opcode, var_name, value in variables:
            item: str = ""
            if "CALL" == dis.opname[opcode]:
                is_method = value[-1]
                value = value[:-1]
                instance_name = ""
                if is_method:
                    instance = value[0]
                    if getattr(instance, "__name__", None):
                        instance_name = instance.__name__
                    elif getattr(instance, "__class__", None):
                        instance_name = instance.__class__.__name__
                    else:
                        instance_name = repr(instance)
                    value = value[1:]
                args = ", ".join(f"{truncate_repr_value(arg)}" for arg in value)
                if getattr(var_name, "__code__", None):
                    item = f"{var_name.__code__.co_name}({args})"
                elif getattr(var_name, "__name__", None):
                    item = f"{var_name.__name__}({args})"
                else:
                    item = f"{var_name}({args})"
                if instance_name:
                    item = f"{instance_name}.{item}"
            elif "STORE_SUBSCR" == dis.opname[opcode]:
                item = f"[{var_name}]={truncate_repr_value(value)}"
            else:
                item = f"{var_name}={truncate_repr_value(value)}"
            if item not in seen:
                seen.add(item)
                text.append(item)
        return " ".join(text)

    def _message_to_html(self, message: str, msg_type: str, log_data: Optional[Dict[str, Any]]) -> str:
        """Converts a single log message into an HTML fragment."""
        event_id = self._next_event_id
        self._next_event_id += 1
        data: Dict[str, Any] = log_data.get("data", {}) if isinstance(log_data, dict) else {}
        self._event_metadata[event_id] = {
            "type": msg_type,
            "filename": data.get("original_filename"),
            "lineno": data.get("lineno"),
            "func": data.get("func"),
            "frame_id": data.get("frame_id"),
            "args": data.get("args"),
            "return_value": data.get("return_value"),
            "tracked_vars": data.get("tracked_vars"),
            "thread_id": data.get("thread_id"),
        }
        stripped_message = message.lstrip()
        indent = len(message) - len(stripped_message)
        is_multiline_stmt = False
        if msg_type == TraceTypes.COLOR_LINE and log_data and isinstance(log_data, dict):
            raw_line = data.get("raw_line", "")
            if "\n" in raw_line:
                is_multiline_stmt = True
            tracked_vars = data.get("tracked_vars")
            if tracked_vars:
                # HTML for debug vars is no longer pre-rendered. It will be created by JS on demand.
                # We still strip the debug comment from the message text.
                debug_part_str = " # Debug: "
                if debug_part_str in stripped_message:
                    stripped_message = stripped_message.split(debug_part_str, 1)[0]

        if is_multiline_stmt:
            indented_statement = data.get("line", "")
            first_line_of_indented = indented_statement.splitlines()[0]
            prefix = stripped_message.split(first_line_of_indented, 1)[0]
            raw_statement = data.get("raw_line", "")
            escaped_prefix_nbsp = html.escape(prefix).replace("§", "&nbsp;").replace(" ", "&nbsp;")
            escaped_first_line_nbsp = html.escape(first_line_of_indented).replace(" ", "&nbsp;")
            escaped_raw_statement = html.escape(raw_statement)
            escaped_content = f"""<div class="multi-line-container">
                <span class="code-preview">{escaped_prefix_nbsp}{escaped_first_line_nbsp}... </span><span class="expand-code-btn" data-i18n-title="expandCodeTitle" title="Toggle view">[+]</span>
                <div class="code-full">
                    <span class="multi-line-prefix">{escaped_prefix_nbsp}</span>
                    <pre class="language-python"><code>{escaped_raw_statement}</code></pre>
                </div>
            </div>"""
        else:
            escaped_content = html.escape(stripped_message).replace("§", "&nbsp;").replace(" ", "&nbsp;")

        original_filename: Optional[str] = data.get("original_filename")
        line_number: Optional[int] = data.get("lineno")
        frame_id: Optional[int] = data.get("frame_id")
        comment_html = ""
        idx: Optional[int] = log_data.get("idx") if isinstance(log_data, dict) else None
        if idx is not None and self._stack_variables.get(idx):
            comment = self.format_stack_variables(self._stack_variables[idx])
            comment_id = f"comment_{idx}"
            comment_html = self._build_comment_html(comment_id, comment) if comment else ""
        view_source_html = self._build_view_source_html(original_filename, line_number, frame_id)
        data_indent_attr = f'data-indent="{indent}"'
        actions_html = ""
        if msg_type == TraceTypes.COLOR_CALL:
            copy_subtree_html = ' <span class="copy-subtree-btn" data-i18n-title="copySubtreeTitle" title="Copy subtree as text">📋</span>'
            focus_subtree_html = ' <span class="focus-subtree-btn" data-i18n-title="focusSubtreeTitle" title="Focus on this subtree (crop)">🔍</span>'
            explain_ai_html = (
                ' <span class="explain-ai-btn" data-i18n-title="explainAITitle" title="Explain with AI">🤖</span>'
            )
            toggle_details_html = ' <span class="toggle-details-btn" data-i18n-title="toggleDetailsTitle" title="Show details for this subtree">👁️</span>'
            actions_html = copy_subtree_html + focus_subtree_html + explain_ai_html + toggle_details_html
        appended_html = f"{view_source_html}{comment_html}{actions_html}"
        html_parts: List[str] = []
        if msg_type == TraceTypes.COLOR_CALL:
            html_parts.extend(
                [
                    f'<div data-event-id="{event_id}" class="foldable {TraceTypes.HTML_CALL}" {data_indent_attr} style="--indent-space: {indent}ch;">',
                    f"    {escaped_content}{appended_html}",
                    "</div>",
                    '<div class="call-group collapsed">',
                ]
            )
        elif msg_type == TraceTypes.COLOR_RETURN:
            html_parts.extend(
                [
                    "</div>",
                    f'<div data-event-id="{event_id}" class="{TraceTypes.HTML_RETURN}" {data_indent_attr} style="padding-left:{indent}ch">',
                    f"    {escaped_content}{appended_html}",
                    "</div>",
                ]
            )
        elif msg_type in (TraceTypes.ERROR, TraceTypes.EXCEPTION, TraceTypes.COLOR_EXCEPTION):
            html_parts.extend(
                [
                    "</div>",
                    f'<div data-event-id="{event_id}" class="{TraceTypes.HTML_ERROR}" {data_indent_attr} style="padding-left:{indent}ch">',
                    f"    {escaped_content}{appended_html}",
                    "</div>",
                ]
            )
        else:
            html_parts.extend(
                [
                    f'<div data-event-id="{event_id}" class="{msg_type}" {data_indent_attr} style="padding-left:{indent}ch">',
                    f"    {escaped_content}{appended_html}",
                    "</div>",
                ]
            )
        html_content = "\n".join(html_parts)
        self._current_size += len(html_content)
        if self._current_size > self._size_limit and not self._size_exceeded:
            self._size_exceeded = True
            size_limit_mb = self._size_limit / (1024 * 1024)
            error_message_template = self._translations.get("htmlSizeExceeded", {}).get(
                self.default_lang,
                "⚠ HTML report size has exceeded {size_limit_mb}MB limit, subsequent content will be ignored",
            )
            error_message = error_message_template.format(size_limit_mb=size_limit_mb)
            return f'<div class="{TraceTypes.HTML_ERROR}">{html.escape(error_message)}</div>\n'
        return html_content

    def _build_debug_vars_html(self, variables: Dict[str, str]) -> str:
        """Builds the HTML for the interactive debug variables UI."""
        if not variables:
            return ""
        compact_items_html = []
        for name, value in variables.items():
            escaped_name = html.escape(name)
            escaped_value = html.escape(value)
            compact_items_html.append(
                f'<span class="var-name">{escaped_name}</span>=<span class="var-value">{escaped_value}</span>'
            )
        compact_view_html = f'<div class="compact-view">{" ".join(compact_items_html)}</div>'
        list_items_html = []
        for name, value in variables.items():
            escaped_name = html.escape(name)
            escaped_value = f"<pre>{html.escape(value)}</pre>"
            list_items_html.append(
                f'<div class="var-entry"><span class="var-name">{escaped_name}</span>: <span class="var-value">{escaped_value}</span></div>'
            )
        list_view_html = f'<div class="list-view">{"".join(list_items_html)}</div>'
        return f"""<div class="debug-vars" data-i18n-title="debugVarsTitle" title="Click to expand/collapse">
            {compact_view_html}
            {list_view_html}
        </div>"""

    def _build_comment_html(self, comment_id: str, comment: str) -> str:
        """Builds the HTML for a collapsible comment."""
        is_long = len(comment) > 64
        short_comment = comment[:64] + "..." if is_long else comment
        short_comment_escaped = html.escape(short_comment)
        full_comment_escaped = html.escape(comment)
        return f'''<span class="comment" id="{comment_id}" onclick="event.stopPropagation(); toggleCommentExpand('{comment_id}', event)">
<span class="comment-preview">{short_comment_escaped}</span>
<span class="comment-full">{full_comment_escaped}</span></span>'''

    def _build_view_source_html(
        self, filename: Optional[str], line_number: Optional[int], frame_id: Optional[int]
    ) -> str:
        """Builds the HTML for a 'view source' button."""
        if not filename or not line_number or frame_id is None:
            return ""
        escaped_filename = filename.replace("\\", "\\\\").replace("'", "\\'")
        return f'<span class="view-source-btn" onclick="showSource(\'{escaped_filename}\', {line_number}, {frame_id})" data-i18n="viewSource">view source</span>'

    def _load_source_file(self, filename: str) -> None:
        """Loads source file content and stores it in a base64 encoded format."""
        if filename in self._source_files:
            return
        try:
            with open(filename, "rb") as f:
                content: str = base64.b64encode(f.read()).decode("utf-8")
                self._source_files[filename] = content
        except (IOError, OSError) as e:
            self._source_files[filename] = f"// Error loading source file: {str(e)}"

    def add_message(self, message: str, msg_type: str, log_data: Optional[Dict[str, Any]] = None) -> None:
        """Adds a pre-formatted message to the internal message list."""
        if self._size_exceeded:
            return
        self._messages.append((message, msg_type, log_data))

    def add_stack_variable_create(self, idx: int, opcode: int, var_name: Any, value: Any) -> None:
        """Records a stack variable creation event for a specific message."""
        if self._size_exceeded:
            return
        if idx not in self._stack_variables:
            self._stack_variables[idx] = []
        self._stack_variables[idx].append((opcode, var_name, value))

    def add_raw_message(self, log_data: Union[str, Dict[str, Any]], color_type: str) -> None:
        """Adds a raw log data object and processes it for HTML rendering."""
        if self._size_exceeded:
            return

        # On any non-line event (like CALL, RETURN), clean up the frame's anchor info.
        # This makes the display logic more robust when functions exit.
        if color_type != TraceTypes.COLOR_LINE and isinstance(log_data, dict):
            frame_id = log_data.get("data", {}).get("frame_id")
            if frame_id is not None and frame_id in self._last_frame_info:
                del self._last_frame_info[frame_id]

        if isinstance(log_data, str):
            message = log_data
        else:
            data = log_data["data"]
            template = log_data["template"]
            if color_type == TraceTypes.COLOR_LINE:
                frame_id = data.get("frame_id")
                original_filename = data.get("original_filename")
                line_number = data.get("lineno")
                formatted_filename = data.get("filename")
                if frame_id is not None and original_filename and line_number is not None and formatted_filename:
                    anchor_info = self._last_frame_info.get(frame_id)
                    # Show full path if the last event wasn't a line, if the file changed, or if it's the first time for this frame.
                    if (
                        self._last_event_type != TraceTypes.COLOR_LINE
                        or self._last_line_event_filename != original_filename
                        or not anchor_info
                    ):
                        # Update the alignment anchor for this frame.
                        self._last_frame_info[frame_id] = (original_filename, formatted_filename, line_number)
                    else:
                        # File is the same as the last line event, simplify the display.
                        _anchor_orig_fn, anchor_formatted_filename, anchor_lineno = anchor_info
                        total_width = len(anchor_formatted_filename) + 1 + len(str(anchor_lineno))
                        # '§' is a placeholder for &nbsp; to avoid HTML space collapsing.
                        aligned_str = f"▷ {line_number}".rjust(total_width + 2, "§")
                        template = template.replace("▷ {filename}:{lineno}", "{aligned_location_str}")
                        data["aligned_location_str"] = aligned_str
                    # Always update the last seen file to track changes for the next line event.
                    self._last_line_event_filename = original_filename

            message = template.format(**data)

        if color_type == TraceTypes.COLOR_LINE and isinstance(log_data, dict) and "lineno" in log_data.get("data", {}):
            data: Dict[str, Any] = log_data["data"]
            original_filename: Optional[str] = data.get("original_filename")
            lineno: Optional[int] = data.get("lineno")
            frame_id: Optional[int] = data.get("frame_id")
            if data.get("tracked_vars"):
                self.line_comment[f"{frame_id}-{original_filename}-{lineno}"] = data["tracked_vars"]
            if original_filename and lineno is not None and frame_id is not None:
                self._executed_lines[original_filename][frame_id].add(lineno)
                self._load_source_file(original_filename)
        self._messages.append((message, color_type, log_data))
        self._last_event_type = color_type

    def generate_html(self) -> str:
        """Generates the final, complete HTML report."""
        buffer: List[str] = []
        error_count: int = 0
        frame_indents: Dict[int, int] = {}
        for _idx, (message, msg_type, log_data) in enumerate(self._messages):
            if self._size_exceeded and msg_type not in (
                TraceTypes.ERROR,
                TraceTypes.EXCEPTION,
                TraceTypes.COLOR_EXCEPTION,
            ):
                continue
            original_indent = len(message) - len(message.lstrip())
            corrected_indent = original_indent
            frame_id: Optional[int] = None
            if isinstance(log_data, dict):
                data = log_data.get("data")
                if isinstance(data, dict):
                    frame_id = data.get("frame_id")
            if frame_id is not None:
                if frame_id not in frame_indents:
                    frame_indents[frame_id] = original_indent
                corrected_indent = frame_indents[frame_id]
            corrected_message = " " * corrected_indent + message.lstrip()
            buffer.append(self._message_to_html(corrected_message, msg_type, log_data))
            if msg_type in (TraceTypes.ERROR, TraceTypes.EXCEPTION, TraceTypes.COLOR_EXCEPTION):
                error_count += 1

        title: str
        if self.config:
            title = f"Trace Report for {self.config.report_name}"
        else:
            title = "Python Trace Report"

        generation_time = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        executed_lines_data: Dict[str, Dict[int, List[int]]] = {
            filename: {frame_id: list(lines) for frame_id, lines in frames.items()}
            for filename, frames in self._executed_lines.items()
        }

        # Perform server-side i18n rendering
        rendered_html = self._render_i18n(self._template, self.default_lang)

        try:
            nav_worker_path = Path(__file__).parent / "static" / "js" / "nav_worker.js"
            nav_worker_script_content = nav_worker_path.read_text("utf-8")
        except FileNotFoundError:
            logging.error(f"Asset file not found: {nav_worker_path}")
            nav_worker_script_content = "console.error('nav_worker.js not found');"

        # Inject data into the template
        final_html = rendered_html.replace("{{title}}", html.escape(title))
        final_html = final_html.replace("{{generation_time}}", generation_time)
        final_html = final_html.replace("{{message_count}}", str(len(self._messages)))
        final_html = final_html.replace("{{error_count}}", str(error_count))
        final_html = final_html.replace("{{content}}", "".join(buffer))

        # Inject JSON data for JavaScript
        final_html = final_html.replace("{{translations_data}}", json.dumps(self._translations))
        final_html = final_html.replace("{{executed_lines_data}}", json.dumps(executed_lines_data))
        final_html = final_html.replace("{{source_files_data}}", json.dumps(self._source_files))
        final_html = final_html.replace("{{comments_data}}", json.dumps(self._comments_data))
        final_html = final_html.replace("{{line_comment}}", json.dumps(self.line_comment))
        final_html = final_html.replace("{{event_metadata_data}}", json.dumps(self._event_metadata))
        final_html = final_html.replace("{{nav_worker_script_content}}", nav_worker_script_content)

        return final_html

    def _create_asset_link(self, source: Path, destination: Path) -> None:
        """
        Creates a symbolic link from source to destination if supported,
        otherwise falls back to copying the file. Skips if link already exists and points to source.
        Ensures parent directories exist before creating the link.
        """
        # Ensure parent directory exists
        destination.parent.mkdir(parents=True, exist_ok=True)

        abs_source = source.resolve()
        if destination.exists():
            if destination.is_symlink():
                current_target = destination.readlink()
                abs_current_target = current_target.resolve()
                if abs_current_target == abs_source:
                    return
            destination.unlink()
        try:
            if hasattr(os, "symlink"):
                os.symlink(source, destination)
            else:
                shutil.copy(source, destination)
        except OSError:
            shutil.copy(source, destination)

    def save_to_file(self, filename: str, is_multi_threaded: bool) -> Path:
        """Saves the generated HTML report to a file."""
        report_dir: Path = Path.cwd() / "tracer-logs"
        report_dir.mkdir(exist_ok=True)
        html_content: str = self.generate_html()
        output_dir: Path
        final_report_path: Path
        if is_multi_threaded:
            timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
            dir_name = f"{Path(filename).stem}_{timestamp}"
            output_dir = report_dir / dir_name
            output_dir.mkdir(exist_ok=True)
            final_report_path = output_dir / "report.html"
        else:
            output_dir = report_dir
            final_report_path = output_dir / filename

        try:
            asset_dir: Path = Path(__file__).parent

            # Copy/Link core assets
            core_assets: List[str] = [
                "tracer_styles.css",
                "translations.json",
            ]
            for asset in core_assets:
                source_asset = asset_dir / asset
                if source_asset.exists():
                    self._create_asset_link(source_asset, output_dir / asset)

            # Copy/Link static resources recursively
            static_dir = asset_dir / "static"
            if static_dir.exists():
                output_static_dir = output_dir / "static"
                output_static_dir.mkdir(exist_ok=True)

                # Recursively copy all static files and directories
                for item in static_dir.rglob("*"):
                    if item.is_file():
                        relative_path = item.relative_to(static_dir)
                        target_path = output_static_dir / relative_path
                        target_path.parent.mkdir(parents=True, exist_ok=True)
                        self._create_asset_link(item, target_path)

        except Exception as e:
            logging.error(f"Failed to copy asset files: {e}")
            print(f"ERROR: Failed to copy asset files: {e}")

        final_report_path.write_text(html_content, encoding="utf-8")
        print(f"Generating HTML report {final_report_path} ...")
        return final_report_path
