/**
 * JavaScript Container Reader for Context Tracer V4 Format
 * 
 * This library provides a browser-compatible reader for trace data containers
 * generated by the Python context tracer with V4 format support.
 */

// Constants matching Python implementation
const MAGIC_NUMBER = new TextEncoder().encode("CTXTRACE");
const FORMAT_VERSION = 4;
const HEADER_RESERVED_BYTES = 256;

// Event type enumeration matching Python
const EventType = {
    CALL: 1,
    RETURN: 2,
    LINE: 3,
    EXCEPTION: 4,
    C_CALL: 5,
    C_RETURN: 6,
    C_RAISE: 7
};

/**
 * SourceManager class - manages source code content storage and retrieval
 */
class SourceManager {
    constructor() {
        this._sourceContent = new Map(); // filename -> base64 content
        this._loadedFiles = new Set(); // Track which files we've attempted to load
    }

    /**
     * Get base64-encoded source content for a file
     * @param {string} filename - File path
     * @returns {string|null} Base64 content or null
     */
    getSourceContent(filename) {
        return this._sourceContent.get(filename) || null;
    }

    /**
     * Get source code lines for a file
     * @param {string} filename - File path
     * @returns {string[]|null} Array of source lines or null
     */
    getSourceLines(filename) {
        const content = this.getSourceContent(filename);
        if (content) {
            try {
                const decoded = atob(content);
                return decoded.split('\n');
            } catch (error) {
                console.warn(`Failed to decode base64 content for ${filename}:`, error);
                return null;
            }
        }
        return null;
    }

    /**
     * Deserialize SourceManager state from JSON bytes
     * @param {Uint8Array} data - Serialized SourceManager data
     * @returns {SourceManager} New SourceManager instance
     */
    static deserialize(data) {
        const text = new TextDecoder().decode(data);
        const state = JSON.parse(text);
        
        const instance = new SourceManager();
        
        // Restore source content
        if (state.source_content) {
            for (const [filename, content] of Object.entries(state.source_content)) {
                instance._sourceContent.set(filename, content);
            }
        }
        
        // Restore loaded files
        if (state.loaded_files) {
            state.loaded_files.forEach(file => instance._loadedFiles.add(file));
        }
        
        return instance;
    }

    /**
     * Get all stored source files with their content
     * @returns {Map<string, string>} Map of filename to base64 content
     */
    getAllSourceFiles() {
        return new Map(this._sourceContent);
    }
}

// V3 format indices for event data lists
const CALL_FUNC_INDEX = 0;
const CALL_ARGS_INDEX = 1;
const RETURN_FUNC_INDEX = 0;
const RETURN_VALUE_INDEX = 1;
const RETURN_VARS_INDEX = 2;
const LINE_CONTENT_INDEX = 0;
const LINE_RAW_INDEX = 1;
const LINE_VARS_INDEX = 2;
const EXCEPTION_FUNC_INDEX = 0;
const EXCEPTION_TYPE_INDEX = 1;
const EXCEPTION_VALUE_INDEX = 2;
const C_CALL_FUNC_INDEX = 0;
const C_CALL_ARG0_INDEX = 1;
const C_RETURN_FUNC_INDEX = 0;
const C_RAISE_FUNC_INDEX = 0;

/**
 * FileManager class - manages file path to ID mapping and dynamic code storage
 */
class FileManager {
    constructor() {
        this._fileToId = new Map();
        this._idToFile = new Map();
        this._dynamicCode = new Map();
        this._nextId = 0;
    }

    /**
     * Get a unique ID for a file path or dynamic code snippet
     * @param {string} path - File path or dynamic code identifier
     * @param {string} [content] - Optional dynamic code content
     * @returns {number} File ID
     */
    getId(path, content = null) {
        if (this._fileToId.has(path)) {
            return this._fileToId.get(path);
        }

        const fileId = this._nextId;
        this._fileToId.set(path, fileId);
        this._idToFile.set(fileId, path);
        
        if (content) {
            this._dynamicCode.set(fileId, content);
        }
        
        this._nextId += 1;
        return fileId;
    }

    /**
     * Retrieve the file path associated with an ID
     * @param {number} fileId - File ID
     * @returns {string|null} File path or null if not found
     */
    getPath(fileId) {
        return this._idToFile.get(fileId) || null;
    }

    /**
     * Get the source code for a file ID, split into lines
     * @param {number} fileId - File ID
     * @returns {string[]|null} Array of source lines or null
     */
    getSourceLines(fileId) {
        if (this._dynamicCode.has(fileId)) {
            return this._dynamicCode.get(fileId).split('\n');
        }

        const path = this.getPath(fileId);
        if (!path) {
            return null;
        }

        // For browser environment, we can't read local files
        // This would need to be handled by pre-loading source files
        return null;
    }

    /**
     * Deserialize FileManager state from JSON bytes
     * @param {Uint8Array} data - Serialized FileManager data
     * @returns {FileManager} New FileManager instance
     */
    static deserialize(data) {
        const text = new TextDecoder().decode(data);
        const state = JSON.parse(text);
        
        const instance = new FileManager();
        
        // Convert string keys back to numbers for JavaScript
        instance._fileToId = new Map(Object.entries(state.file_to_id));
        
        instance._idToFile = new Map(
            Object.entries(state.id_to_file).map(([k, v]) => [parseInt(k, 10), v])
        );
        
        instance._dynamicCode = new Map(
            Object.entries(state.dynamic_code).map(([k, v]) => [parseInt(k, 10), v])
        );
        
        instance._nextId = state.next_id;
        
        return instance;
    }
}

/**
 * DataContainerReader class - reads and decrypts trace data containers
 */
class DataContainerReader {
    /**
     * Create a new container reader
     * @param {ArrayBuffer} arrayBuffer - Container file data
     * @param {Uint8Array} key - Decryption key (16, 24, or 32 bytes)
     */
    constructor(arrayBuffer, key) {
        this._arrayBuffer = arrayBuffer;
        this._dataView = new DataView(arrayBuffer);
        this._key = key;
        this._offset = 0;
        this.fileManager = null;
        this.sourceManager = null;
        this._formatVersion = 1;
        this._metadataPosition = 0;
    }

    /**
     * Open and parse the container
     * @returns {Promise<void>}
     */
    async open() {
        // Verify magic number
        const magic = new Uint8Array(this._arrayBuffer, 0, 8);
        if (!this._arraysEqual(magic, MAGIC_NUMBER)) {
            throw new Error("Not a valid context tracer file");
        }

        // Read format version
        this._formatVersion = this._dataView.getUint16(8, false); // big endian
        if (this._formatVersion > FORMAT_VERSION) {
            throw new Error(`Unsupported format version: ${this._formatVersion}. This tool supports up to version ${FORMAT_VERSION}.`);
        }

        // Skip reserved bytes
        this._offset = 10 + 8 + HEADER_RESERVED_BYTES;

        // V4+ format: Metadata (FileManager + SourceManager) stored at end with pointer in header
        if (this._formatVersion >= 4) {
            this._metadataPosition = this._readUint64(10); // Position after magic + version
            
            // Read metadata from end of file
            if (this._metadataPosition > 0) {
                const currentPos = this._offset;
                this._offset = this._metadataPosition;
                
                const metadataLength = this._dataView.getUint32(this._offset, false);
                this._offset += 4;
                
                const encryptedMetadata = new Uint8Array(this._arrayBuffer, this._offset, metadataLength);
                const metadataBytes = await this._decrypt(encryptedMetadata);
                const metadataText = new TextDecoder().decode(metadataBytes);
                const metadata = JSON.parse(metadataText);
                
                // Deserialize FileManager
                const fmData = metadata.file_manager;
                if (fmData) {
                    this.fileManager = FileManager.deserialize(new TextEncoder().encode(fmData));
                } else {
                    this.fileManager = new FileManager();
                }
                
                // Deserialize SourceManager if available
                const smData = metadata.source_manager;
                if (smData) {
                    this.sourceManager = SourceManager.deserialize(new TextEncoder().encode(smData));
                }
                
                // Restore position
                this._offset = currentPos;
            } else {
                // No metadata (empty container)
                this.fileManager = new FileManager();
                this.sourceManager = null;
            }
        }
    }

    /**
     * Iterator for reading trace events
     * @returns {AsyncGenerator<Object>}
     */
    async *events() {
        if (!this.fileManager) {
            throw new Error("Container must be opened before iteration");
        }

        while (this._offset < this._arrayBuffer.byteLength) {
            // For V4 format, check if we've reached the metadata section
            if (this._formatVersion >= 4 && this._metadataPosition > 0) {
                if (this._offset >= this._metadataPosition) {
                    break;
                }
            }

            // Read record length prefix
            if (this._offset + 4 > this._arrayBuffer.byteLength) {
                break;
            }
            
            const recordLength = this._dataView.getUint32(this._offset, false);
            this._offset += 4;

            // Check if we have enough data for the record
            if (this._offset + recordLength > this._arrayBuffer.byteLength) {
                throw new Error("Incomplete record found at end of file");
            }

            // Read and decrypt the encrypted record
            const encryptedRecord = new Uint8Array(this._arrayBuffer, this._offset, recordLength);
            this._offset += recordLength;

            try {
                const decryptedRecord = await this._decrypt(encryptedRecord);
                const rawEvent = await this._decodeMsgPack(decryptedRecord);
                
                // Convert list-based event to object format
                const event = this._parseEvent(rawEvent);
                yield event;
            } catch (error) {
                console.warn("Failed to decrypt or parse event:", error);
                continue;
            }
        }
    }

    /**
     * Parse V3 list-based event format into object
     * @param {Array} rawEvent - Raw event data as array
     * @returns {Object} Parsed event object
     */
    _parseEvent(rawEvent) {
        if ([3, 4].includes(this._formatVersion)) {
            return {
                event_type: rawEvent[0],
                timestamp: rawEvent[1],
                thread_id: rawEvent[2],
                frame_id: rawEvent[3],
                file_id: rawEvent[4],
                lineno: rawEvent[5],
                data: rawEvent[6] // This is now a list from V3/V4 format
            };
        }

        throw new Error(`Unsupported format version: ${this._formatVersion}`);
    }

    /**
     * Decrypt AES-GCM encrypted data
     * @param {Uint8Array} ciphertext - Encrypted data with nonce + tag
     * @returns {Promise<Uint8Array>} Decrypted data
     */
    async _decrypt(ciphertext) {
        const nonce = ciphertext.slice(0, 16);
        const tag = ciphertext.slice(16, 32);
        const encryptedData = ciphertext.slice(32);

        // Node.js compatibility: use node's crypto module if available
        if (typeof process !== 'undefined' && process.versions && process.versions.node) {
            const crypto = require('crypto');
            
            // For Node.js, we need to use the built-in crypto module
            const decipher = crypto.createDecipheriv('aes-256-gcm', this._key, nonce);
            decipher.setAuthTag(tag);
            
            let decrypted = decipher.update(encryptedData);
            decrypted = Buffer.concat([decrypted, decipher.final()]);
            
            return new Uint8Array(decrypted);
        } else {
            // Browser environment: use Web Crypto API
            const cryptoKey = await crypto.subtle.importKey(
                'raw', this._key, 'AES-GCM', false, ['decrypt']
            );

            // Combine encrypted data and tag for decryption
            const combinedData = new Uint8Array(encryptedData.length + tag.length);
            combinedData.set(encryptedData);
            combinedData.set(tag, encryptedData.length);

            const decrypted = await crypto.subtle.decrypt(
                { name: 'AES-GCM', iv: nonce, tagLength: 128 },
                cryptoKey,
                combinedData
            );

            return new Uint8Array(decrypted);
        }
    }

    /**
     * Encrypt data for testing (exposed for unit tests)
     * @param {Uint8Array} plaintext - Data to encrypt
     * @returns {Uint8Array} Encrypted data
     */
    _encryptForTest(plaintext) {
        // Simple XOR encryption for testing (not secure, for testing only)
        const result = new Uint8Array(plaintext.length + 32); // nonce + tag + data
        
        // Add dummy nonce and tag
        for (let i = 0; i < 32; i++) {
            result[i] = i;
        }
        
        // Copy plaintext
        for (let i = 0; i < plaintext.length; i++) {
            result[32 + i] = plaintext[i];
        }
        
        return result;
    }

    /**
     * Decode MessagePack data
     * @param {Uint8Array} data - MessagePack encoded data
     * @returns {Promise<any>} Decoded data
     */
    async _decodeMsgPack(data) {
        // Use global MessagePack object loaded via script tag
        if (typeof MessagePack !== 'undefined') {
            return MessagePack.decode(data);
        }
        throw new Error('MessagePack library not loaded');
    }

    /**
     * Read 64-bit unsigned integer (big endian)
     * @param {number} offset - Byte offset
     * @returns {number} 64-bit integer (as number, may lose precision for very large values)
     */
    _readUint64(offset) {
        const high = this._dataView.getUint32(offset, false);
        const low = this._dataView.getUint32(offset + 4, false);
        return (high * 0x100000000) + low;
    }

    /**
     * Compare two Uint8Arrays for equality
     * @param {Uint8Array} a - First array
     * @param {Uint8Array} b - Second array
     * @returns {boolean} True if arrays are equal
     */
    _arraysEqual(a, b) {
        if (a.length !== b.length) return false;
        for (let i = 0; i < a.length; i++) {
            if (a[i] !== b[i]) return false;
        }
        return true;
    }
}

// Export for browser and Node.js environments
if (typeof window !== 'undefined') {
    window.DataContainerReader = DataContainerReader;
    window.FileManager = FileManager;
    window.SourceManager = SourceManager;
    window.EventType = EventType;
}

if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        DataContainerReader,
        FileManager,
        SourceManager,
        EventType
    };
}