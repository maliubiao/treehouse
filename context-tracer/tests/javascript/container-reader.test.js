/**
 * Test suite for JavaScript Container Reader
 */

// Mock Web Crypto API for Node.js environment
if (typeof crypto === 'undefined') {
    global.crypto = require('crypto').webcrypto;
}

// Import the container reader
const { DataContainerReader, FileManager, EventType } = require('../../src/context_tracer/static/js/container-reader.js');

// Mock msgpack for Node.js
const msgpack = require('@msgpack/msgpack');

// Mock the dynamic import in the container reader
const originalDecodeMsgPack = DataContainerReader.prototype._decodeMsgPack;
DataContainerReader.prototype._decodeMsgPack = async function(data) {
    return msgpack.decode(data);
};

describe('Container Reader', () => {
    describe('FileManager', () => {
        let fileManager;

        beforeEach(() => {
            fileManager = new FileManager();
        });

        test('should create FileManager instance', () => {
            expect(fileManager).toBeInstanceOf(FileManager);
            expect(fileManager._fileToId).toBeInstanceOf(Map);
            expect(fileManager._idToFile).toBeInstanceOf(Map);
        });

        test('should assign unique IDs to files', () => {
            const id1 = fileManager.getId('/path/to/file1.py');
            const id2 = fileManager.getId('/path/to/file2.py');
            const id3 = fileManager.getId('/path/to/file1.py'); // Same file

            expect(id1).toBe(0);
            expect(id2).toBe(1);
            expect(id3).toBe(0); // Should return same ID for same file
        });

        test('should retrieve file paths by ID', () => {
            const path = '/path/to/test.py';
            const id = fileManager.getId(path);
            
            expect(fileManager.getPath(id)).toBe(path);
            expect(fileManager.getPath(999)).toBeNull(); // Non-existent ID
        });

        test('should handle dynamic code', () => {
            const code = 'print("Hello World")';
            const id = fileManager.getId('<dynamic>', code);
            
            expect(fileManager._dynamicCode.get(id)).toBe(code);
            expect(fileManager.getSourceLines(id)).toEqual(['print("Hello World")']);
        });

        test('should deserialize from JSON', () => {
            const serializedData = JSON.stringify({
                file_to_id: { '/test/file.py': 0, '/another/file.py': 1 },
                id_to_file: { '0': '/test/file.py', '1': '/another/file.py' },
                dynamic_code: { '2': 'dynamic content' },
                next_id: 3
            });

            const bytes = new TextEncoder().encode(serializedData);
            const deserialized = FileManager.deserialize(bytes);

            expect(deserialized).toBeInstanceOf(FileManager);
            expect(deserialized.getPath(0)).toBe('/test/file.py');
            expect(deserialized.getPath(1)).toBe('/another/file.py');
            expect(deserialized._nextId).toBe(3);
        });
    });

    describe('DataContainerReader', () => {
        test('should create DataContainerReader instance', () => {
            const arrayBuffer = new ArrayBuffer(100);
            const key = new Uint8Array(16); // 16-byte key
            const reader = new DataContainerReader(arrayBuffer, key);

            expect(reader).toBeInstanceOf(DataContainerReader);
            expect(reader._arrayBuffer).toBe(arrayBuffer);
            expect(reader._key).toBe(key);
        });

        // Note: More comprehensive tests would require actual container files
        // generated by the Python tracer. These would test:
        // - Magic number validation
        // - Format version parsing
        // - FileManager position reading (V4 format)
        // - AES-GCM decryption
        // - Event iteration
    });

    describe('EventType constants', () => {
        test('should have correct event type values', () => {
            expect(EventType.CALL).toBe(1);
            expect(EventType.RETURN).toBe(2);
            expect(EventType.LINE).toBe(3);
            expect(EventType.EXCEPTION).toBe(4);
            expect(EventType.C_CALL).toBe(5);
            expect(EventType.C_RETURN).toBe(6);
            expect(EventType.C_RAISE).toBe(7);
        });
    });

    describe('SourceManager', () => {
        let sourceManager;

        beforeEach(() => {
            sourceManager = new SourceManager();
        });

        test('should create SourceManager instance', () => {
            expect(sourceManager).toBeInstanceOf(SourceManager);
            expect(sourceManager._sourceContent).toBeInstanceOf(Map);
            expect(sourceManager._loadedFiles).toBeInstanceOf(Set);
        });

        test('should deserialize from JSON', () => {
            const serializedData = JSON.stringify({
                source_content: { '/test/file.py': 'cHJpbnQoIkhlbGxvIFdvcmxkIik=' }, // base64 of "print(\"Hello World\")"
                loaded_files: ['/test/file.py', '/another/file.py']
            });

            const bytes = new TextEncoder().encode(serializedData);
            const deserialized = SourceManager.deserialize(bytes);

            expect(deserialized).toBeInstanceOf(SourceManager);
            expect(deserialized.getSourceContent('/test/file.py')).toBe('cHJpbnQoIkhlbGxvIFdvcmxkIik=');
            expect(deserialized._loadedFiles.has('/test/file.py')).toBe(true);
        });

        test('should get source lines from base64 content', () => {
            const base64Content = 'cHJpbnQoIkhlbGxvIFdvcmxkIik='; // "print(\"Hello World\")"
            sourceManager._sourceContent.set('/test/file.py', base64Content);

            const lines = sourceManager.getSourceLines('/test/file.py');
            expect(lines).toEqual(['print("Hello World")']);
        });

        test('should return null for non-existent file', () => {
            expect(sourceManager.getSourceLines('/nonexistent/file.py')).toBeNull();
        });
    });

    describe('V4 Format Support', () => {
        test('should handle V4 metadata with both FileManager and SourceManager', async () => {
            // Create mock V4 metadata
            const fileManagerData = JSON.stringify({
                file_to_id: { '/test/file.py': 0, '/another/file.py': 1 },
                id_to_file: { '0': '/test/file.py', '1': '/another/file.py' },
                dynamic_code: {},
                next_id: 2
            });

            const sourceManagerData = JSON.stringify({
                source_content: { '/test/file.py': 'cHJpbnQoIkhlbGxvIFdvcmxkIik=' },
                loaded_files: ['/test/file.py']
            });

            const metadata = {
                file_manager: fileManagerData,
                source_manager: sourceManagerData
            };

            // Mock the container reader to test V4 format parsing
            const reader = new DataContainerReader(new ArrayBuffer(100), new Uint8Array(16));
            
            // Test metadata parsing directly - simulate decryption by just using the plaintext
            // (since _encryptForTest adds 32 bytes of header, we need to slice it off)
            const metadataBytes = new TextEncoder().encode(JSON.stringify(metadata));
            const encryptedData = reader._encryptForTest(metadataBytes);
            // For testing, just use the plaintext part (skip the 32-byte header)
            const decryptedMetadata = encryptedData.slice(32);
            const parsedMetadata = JSON.parse(new TextDecoder().decode(decryptedMetadata));

            // Test FileManager deserialization
            const fmBytes = new TextEncoder().encode(parsedMetadata.file_manager);
            const fileManager = FileManager.deserialize(fmBytes);
            expect(fileManager.getPath(0)).toBe('/test/file.py');

            // Test SourceManager deserialization
            const smBytes = new TextEncoder().encode(parsedMetadata.source_manager);
            const sourceManager = SourceManager.deserialize(smBytes);
            expect(sourceManager.getSourceContent('/test/file.py')).toBe('cHJpbnQoIkhlbGxvIFdvcmxkIik=');
        });
    });
});

// Export for manual testing
if (typeof module !== 'undefined') {
    module.exports = { DataContainerReader, FileManager, SourceManager, EventType };
}