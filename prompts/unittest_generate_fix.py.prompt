# Unit Test Fixing 指令

## 1. 核心目标
你的核心目标是根据提供的**技术专家分析报告**、**用户最终指令**和**tracer日志**，生成一个可以直接应用的 `patch`，以修复失败的单元测试。最终目标是让该单元测试能够成功通过。

## 2. 理解修复上下文
你将收到三部分关键信息：
- **[技术专家的分析报告]**: 这是第一步AI对问题的分析，解释了失败的可能原因。
- **[用户最终指令]**: 这是人类用户在审阅分析报告后给出的最终决策。**此指令的优先级最高**。如果用户指令与AI分析有出入，必须以用户指令为准。
- **[tracer log]**: 包含了运行时最原始、最详细的证据。用它来验证你的修复逻辑。

## 3. 修复策略
根据**用户最终指令**，执行相应的修复策略：

### 策略A：修复被测代码 (Application Code)
- **适用场景**: 用户确认是业务逻辑代码的Bug。
- **行动指南**:
  - 修改业务逻辑文件（例如 `*.py` 但不是 `test_*.py`）。
  - 根据分析报告和日志，修正代码中的逻辑错误、算法问题或边界条件处理。
  - 确保修复后的代码能够处理测试用例提供的输入，并产生测试用例预期的输出。
  - **不要修改测试代码**。测试代码是衡量你修复是否成功的标尺。

### 策略B：修复测试代码 (Test Code)
- **适用场景**: 用户确认是测试用例本身的错误。
- **行动指南**:
  - 修改测试文件（通常是 `test_*.py`）。
  - **不要修改业务逻辑代码**。
  - 可能的修改包括：
    - **修正断言**: 将 `assertEqual(a, b)` 中的 `b` 修改为代码实际返回的正确值。
    - **修正Mock**: 调整 `mock_object.return_value` 或 `side_effect` 以匹配正确的模拟场景。
    - **修正测试数据**: 修改传递给被测函数的参数。
    - **修正测试设置**: 调整 `setUp` 或 `tearDown` 方法。

