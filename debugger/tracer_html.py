"""
HTML Report Renderer for Python Tracer.

This module provides the CallTreeHtmlRender class, which is responsible for
transforming raw trace data into an interactive and human-readable HTML report.
"""

import base64
import datetime
import dis
import html
import json
import logging
import shutil
from collections import defaultdict
from pathlib import Path
from typing import TYPE_CHECKING, Any, DefaultDict, Dict, List, Optional, Set, Tuple, Union

from .tracer_common import TraceTypes, truncate_repr_value

if TYPE_CHECKING:
    from .tracer import TraceLogic


class CallTreeHtmlRender:
    """
    Renders trace logs into a feature-rich HTML report.

    This class processes raw log messages generated by the tracer, formats them
    into HTML, and embeds them in a template that includes JavaScript for
    interactivity (e.g., searching, folding/unfolding call stacks, viewing source).

    Attributes:
        trace_logic (TraceLogic): The parent TraceLogic instance providing context.
        _messages (List[Tuple[str, str, Optional[Dict[str, Any]]]]): A list to store log messages.
            Each tuple contains the formatted message string, message type, and original log data.
        _executed_lines (DefaultDict[str, DefaultDict[int, Set[int]]]): A nested dictionary mapping
            `filename -> frame_id -> set of executed line numbers`.
        _source_files (Dict[str, str]): A cache for base64 encoded source file contents.
        _stack_variables (Dict[int, List[Tuple[int, Any, Any]]]): Maps a message index to its stack variables.
        _comments_data (DefaultDict[str, DefaultDict[int, List[str]]]): Maps filename and line number to comments.
        current_message_id (int): A counter for messages, used for unique IDs.
        _size_limit (int): The maximum size of the HTML report in bytes to prevent performance issues.
        _current_size (int): The current calculated size of the generated HTML content.
        _size_exceeded (bool): Flag indicating if the size limit has been reached.
        _html_template (str): The HTML template string for the final report.
    """

    def __init__(self, trace_logic: "TraceLogic"):
        """
        Initializes the CallTreeHtmlRender instance.

        Args:
            trace_logic: The parent TraceLogic instance that holds the trace configuration and state.
        """
        self.trace_logic: "TraceLogic" = trace_logic
        self._messages: List[Tuple[str, str, Optional[Dict[str, Any]]]] = []
        self._executed_lines: DefaultDict[str, DefaultDict[int, Set[int]]] = defaultdict(lambda: defaultdict(set))
        self._source_files: Dict[str, str] = {}
        self._stack_variables: Dict[int, List[Tuple[int, Any, Any]]] = {}
        self._comments_data: DefaultDict[str, DefaultDict[int, List[str]]] = defaultdict(lambda: defaultdict(list))
        self.current_message_id: int = 0
        self._size_limit: int = 100 * 1024 * 1024  # 100 MB
        self._current_size: int = 0
        self._size_exceeded: bool = False
        self._html_template: str = """
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>Python Trace Report</title>
            <link rel="stylesheet" href="../tracer_styles.css">
            <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css"
                rel="stylesheet" id="prism-theme">
            <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css"
                rel="stylesheet">
            <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.css"
                rel="stylesheet">
        </head>
        <body>
            <div id="sourceDialog"  class="source-dialog" style="display: none;">
                    <div class="floating-close-btn" id="dialogCloseBtn">&times;</div>
                    <div class="close-overlay"></div>
                    <div class="source-header">
                        <div class="source-title" id="sourceTitle"></div>
                    </div>
                    <div class="source-content" id="sourceContent"></div>
            </div>
            <h1>Python Trace Report</h1>
            <div class="summary">
                <p>Generated at: {generation_time}</p>
                <p>Total messages: {message_count}</p>
                <p>Errors: {error_count}</p>
                <div class="theme-selector">
                    <label>Theme: </label>
                    <select id="themeSelector">
                        <!-- Options will be populated by JavaScript -->
                    </select>
                </div>
            </div>
            <div id="controls">
                <input type="text" id="search" placeholder="Search messages...">
                <button id="expandAll">Expand All</button>
                <button id="collapseAll">Collapse All</button>
                <button id="skeletonViewBtn">Ê°ÜÊû∂Ê®°Âºè</button>
                <button id="exportBtn">Export as HTML</button>
            </div>
            <div id="content">\n{content}\n</div>
            <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
            <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
            <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
            <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.js"></script>
            <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js"></script>
            <script src="../tracer_scripts.js"></script>
            <script>
                window.executedLines = {executed_lines_data};
                window.sourceFiles = {source_files_data};
                window.commentsData = {comments_data};
            </script>
        </body>
        </html>
        """

    def format_stack_variables(self, variables: List[Tuple[int, Any, Any]]) -> str:
        """
        Formats a list of stack variables into a compact string representation.

        Args:
            variables: A list of tuples, each containing (opcode, variable_name, value).

        Returns:
            A space-separated string of formatted variables.
        """
        if not variables:
            return ""
        text: List[str] = []
        seen: Set[str] = set()
        for opcode, var_name, value in variables:
            item: str = ""
            if "CALL" == dis.opname[opcode]:
                is_method = value[-1]
                value = value[:-1]
                instance_name = ""
                if is_method:
                    instance = value[0]
                    if getattr(instance, "__name__", None):
                        instance_name = instance.__name__
                    elif getattr(instance, "__class__", None):
                        instance_name = instance.__class__.__name__
                    else:
                        instance_name = repr(instance)
                    value = value[1:]
                args = ", ".join(f"{truncate_repr_value(arg)}" for arg in value)
                if getattr(var_name, "__code__", None):
                    item = f"{var_name.__code__.co_name}({args})"
                elif getattr(var_name, "__name__", None):
                    item = f"{var_name.__name__}({args})"
                else:
                    item = f"{var_name}({args})"
                if instance_name:
                    item = f"{instance_name}.{item}"
            elif "STORE_SUBSCR" == dis.opname[opcode]:
                item = f"[{var_name}]={truncate_repr_value(value)}"
            else:
                item = f"{var_name}={truncate_repr_value(value)}"
            if item not in seen:
                seen.add(item)
                text.append(item)
        return " ".join(text)

    def _message_to_html(self, message: str, msg_type: str, log_data: Optional[Dict[str, Any]]) -> str:
        """
        Converts a single log message into an HTML fragment.

        Args:
            message: The formatted log message string.
            msg_type: The type of the message (e.g., 'call', 'return').
            log_data: The raw dictionary of data associated with the log message.

        Returns:
            An HTML string representing the log message.
        """
        stripped_message = message.lstrip()
        indent = len(message) - len(stripped_message)
        escaped_content = html.escape(stripped_message).replace(" ", "&nbsp;")

        data: Dict[str, Any] = log_data.get("data", {}) if isinstance(log_data, dict) else {}
        original_filename: Optional[str] = data.get("original_filename")
        line_number: Optional[int] = data.get("lineno")
        frame_id: Optional[int] = data.get("frame_id")
        comment_html = ""
        idx: Optional[int] = log_data.get("idx") if isinstance(log_data, dict) else None
        if idx is not None and self._stack_variables.get(idx):
            comment = self.format_stack_variables(self._stack_variables[idx])
            comment_id = f"comment_{idx}"
            comment_html = self._build_comment_html(comment_id, comment) if comment else ""

        view_source_html = self._build_view_source_html(original_filename, line_number, frame_id)

        data_indent_attr = f'data-indent="{indent}"'
        actions_html = ""
        if msg_type == TraceTypes.COLOR_CALL:
            copy_subtree_html = ' <span class="copy-subtree-btn" title="Copy subtree as text">üìã</span>'
            focus_subtree_html = ' <span class="focus-subtree-btn" title="Focus on this subtree (crop)">üîç</span>'
            actions_html = copy_subtree_html + focus_subtree_html

        html_parts: List[str] = []
        if msg_type == TraceTypes.COLOR_CALL:
            html_parts.extend(
                [
                    f'<div class="foldable {TraceTypes.HTML_CALL}" {data_indent_attr} style="padding-left:{indent}px">',
                    f"    {escaped_content}{view_source_html}{comment_html}{actions_html}",
                    "</div>",
                    '<div class="call-group collapsed">',
                ]
            )
        elif msg_type == TraceTypes.COLOR_RETURN:
            html_parts.extend(
                [
                    "</div>",
                    f'<div class="{TraceTypes.HTML_RETURN}" {data_indent_attr} style="padding-left:{indent}px">',
                    f"    {escaped_content}{comment_html}",
                    "</div>",
                ]
            )
        elif msg_type in (TraceTypes.ERROR, TraceTypes.EXCEPTION, TraceTypes.COLOR_EXCEPTION):
            html_parts.extend(
                [
                    "</div>",
                    f'<div class="{TraceTypes.HTML_ERROR}" {data_indent_attr} style="padding-left:{indent}px">',
                    f"    {escaped_content}{view_source_html}{comment_html}",
                    "</div>",
                ]
            )
        else:
            html_parts.extend(
                [
                    f'<div class="{msg_type}" {data_indent_attr} style="padding-left:{indent}px">',
                    f"    {escaped_content}{view_source_html}{comment_html}",
                    "</div>",
                ]
            )
        html_content = "\n".join(html_parts) + "\n"
        self._current_size += len(html_content)
        if self._current_size > self._size_limit and not self._size_exceeded:
            self._size_exceeded = True
            size_limit_mb = self._size_limit / (1024 * 1024)
            return f'<div class="{TraceTypes.HTML_ERROR}">‚ö† HTMLÊä•ÂëäÂ§ßÂ∞èÂ∑≤Ë∂ÖËøá{size_limit_mb}MBÈôêÂà∂ÔºåÂêéÁª≠ÂÜÖÂÆπÂ∞ÜË¢´ÂøΩÁï•</div>\n'
        return html_content

    def _build_comment_html(self, comment_id: str, comment: str) -> str:
        """
        Builds the HTML for a collapsible comment.

        Args:
            comment_id: The unique ID for the comment's HTML element.
            comment: The full text content of the comment.

        Returns:
            An HTML string for the comment span.
        """
        is_long = len(comment) > 64
        short_comment = comment[:64] + "..." if is_long else comment
        short_comment_escaped = html.escape(short_comment)
        full_comment_escaped = html.escape(comment)
        return f'''<span class="comment" id="{comment_id}" 
onclick="event.stopPropagation(); toggleCommentExpand('{comment_id}', event)">
<span class="comment-preview">{short_comment_escaped}</span>
<span class="comment-full">{full_comment_escaped}</span></span>'''

    def _build_view_source_html(
        self, filename: Optional[str], line_number: Optional[int], frame_id: Optional[int]
    ) -> str:
        """
        Builds the HTML for a 'view source' button.

        Args:
            filename: The path to the source file.
            line_number: The line number to highlight.
            frame_id: The ID of the frame to associate with the source view.

        Returns:
            An HTML string for the button, or an empty string if data is missing.
        """
        if not filename or not line_number or frame_id is None:
            return ""
        # Escape backslashes in filenames (important for Windows paths)
        escaped_filename = filename.replace("\\", "\\\\").replace("'", "\\'")
        return f'<span class="view-source-btn" onclick="showSource(\'{escaped_filename}\', {line_number}, {frame_id})">view source</span>'

    def _load_source_file(self, filename: str) -> None:
        """
        Loads source file content and stores it in a base64 encoded format.

        If the file is already loaded, it does nothing.

        Args:
            filename: The path to the source file.
        """
        if filename in self._source_files:
            return
        try:
            with open(filename, "rb") as f:
                content: str = base64.b64encode(f.read()).decode("utf-8")
                self._source_files[filename] = content
        except (IOError, OSError) as e:
            self._source_files[filename] = f"// Error loading source file: {str(e)}"

    def add_message(self, message: str, msg_type: str, log_data: Optional[Dict[str, Any]] = None) -> None:
        """
        Adds a pre-formatted message to the internal message list.

        Args:
            message: The formatted message string.
            msg_type: The category of the message (e.g., call, return).
            log_data: The associated raw log data dictionary.
        """
        if self._size_exceeded:
            return
        self._messages.append((message, msg_type, log_data))

    def add_stack_variable_create(self, idx: int, opcode: int, var_name: Any, value: Any) -> None:
        """
        Records a stack variable creation event for a specific message.

        Args:
            idx: The index of the message this variable is associated with.
            opcode: The bytecode operation code.
            var_name: The name of the variable.
            value: The value of the variable.
        """
        if self._size_exceeded:
            return
        if idx not in self._stack_variables:
            self._stack_variables[idx] = []
        self._stack_variables[idx].append((opcode, var_name, value))

    def add_raw_message(self, log_data: Union[str, Dict[str, Any]], color_type: str) -> None:
        """
        Adds a raw log data object and processes it for HTML rendering.

        This method formats the log data, tracks executed lines, loads source
        code, and appends the result to the message list.

        Args:
            log_data: The raw log data, which can be a string or a dictionary.
            color_type: The color/type category for the message.
        """
        if self._size_exceeded:
            return

        if isinstance(log_data, str):
            message = log_data
        else:
            # Pre-format the message to avoid duplicate formatting.
            message = log_data["template"].format(**log_data["data"])

        if color_type == TraceTypes.COLOR_LINE and isinstance(log_data, dict) and "lineno" in log_data.get("data", {}):
            data: Dict[str, Any] = log_data["data"]
            original_filename: Optional[str] = data.get("original_filename")
            lineno: Optional[int] = data.get("lineno")
            frame_id: Optional[int] = data.get("frame_id")
            if original_filename and lineno is not None and frame_id is not None:
                self._executed_lines[original_filename][frame_id].add(lineno)
                self._load_source_file(original_filename)

        self._messages.append((message, color_type, log_data))

    def generate_html(self) -> str:
        """
        Generates the final, complete HTML report.

        This method iterates through all collected messages, converts them to HTML,
        and injects the result, along with metadata and supporting data (like
        executed lines and source files), into the main HTML template.

        Returns:
            A string containing the full HTML report.
        """
        buffer: List[str] = []
        error_count: int = 0
        for _idx, (message, msg_type, log_data) in enumerate(self._messages):
            if self._size_exceeded and msg_type not in (
                TraceTypes.ERROR,
                TraceTypes.EXCEPTION,
                TraceTypes.COLOR_EXCEPTION,
            ):
                continue
            buffer.append(self._message_to_html(message, msg_type, log_data))
            if msg_type in (TraceTypes.ERROR, TraceTypes.EXCEPTION, TraceTypes.COLOR_EXCEPTION):
                error_count += 1

        generation_time = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        executed_lines_data: Dict[str, Dict[int, List[int]]] = {
            filename: {frame_id: list(lines) for frame_id, lines in frames.items()}
            for filename, frames in self._executed_lines.items()
        }
        executed_lines_json: str = json.dumps(executed_lines_data)
        source_files_json: str = json.dumps(self._source_files)
        comments_json: str = json.dumps(self._comments_data)

        return self._html_template.format(
            generation_time=generation_time,
            message_count=len(self._messages),
            error_count=error_count,
            content="".join(buffer),
            executed_lines_data=executed_lines_json,
            source_files_data=source_files_json,
            comments_data=comments_json,
        )

    def save_to_file(self, filename: str, is_multi_threaded: bool) -> Path:
        """
        Saves the generated HTML report to a file.

        If the trace was multi-threaded, it creates a self-contained directory
        with the HTML report and its CSS/JS assets. Otherwise, it saves a single
        HTML file and assumes assets are in a relative parent directory.

        Args:
            filename: The base name for the report file (e.g., "report.html").
            is_multi_threaded: True if the trace captured multiple threads.

        Returns:
            The Path object pointing to the final saved HTML file.
        """
        report_dir: Path = Path(__file__).parent / "logs"
        report_dir.mkdir(exist_ok=True)
        html_content: str = self.generate_html()

        final_report_path: Path
        if is_multi_threaded:
            timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
            dir_name = f"{Path(filename).stem}_{timestamp}"
            output_dir = report_dir / dir_name
            output_dir.mkdir(exist_ok=True)
            final_report_path = output_dir / "report.html"

            # Copy asset files
            try:
                asset_dir: Path = Path(__file__).parent
                assets: List[str] = ["tracer_styles.css", "tracer_scripts.js"]
                for asset in assets:
                    source_asset = asset_dir / asset
                    if source_asset.exists():
                        shutil.copy(source_asset, output_dir / asset)

                # Adjust asset paths in HTML to be relative to the new directory
                html_content = html_content.replace('href="../tracer_styles.css"', 'href="tracer_styles.css"')
                html_content = html_content.replace('src="../tracer_scripts.js"', 'src="tracer_scripts.js"')
            except Exception as e:
                logging.error(f"Êó†Ê≥ïÂ§çÂà∂ËµÑÊ∫êÊñá‰ª∂: {e}")
                print(f"ERROR: Êó†Ê≥ïÂ§çÂà∂ËµÑÊ∫êÊñá‰ª∂: {e}")

        else:
            final_report_path = report_dir / filename

        final_report_path.write_text(html_content, encoding="utf-8")
        print(f"Ê≠£Âú®ÁîüÊàêHTMLÊä•Âëä {final_report_path} ...")
        return final_report_path
